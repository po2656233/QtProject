// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: gamecomm.proto

#ifndef PROTOBUF_INCLUDED_gamecomm_2eproto
#define PROTOBUF_INCLUDED_gamecomm_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3007000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3007000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_gamecomm_2eproto

// Internal implementation detail -- do not use these members.
struct TableStruct_gamecomm_2eproto {
  static const ::google::protobuf::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::ParseTable schema[11]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors_gamecomm_2eproto();
namespace go {
class GameBet;
class GameBetDefaultTypeInternal;
extern GameBetDefaultTypeInternal _GameBet_default_instance_;
class GameBetResult;
class GameBetResultDefaultTypeInternal;
extern GameBetResultDefaultTypeInternal _GameBetResult_default_instance_;
class GameHost;
class GameHostDefaultTypeInternal;
extern GameHostDefaultTypeInternal _GameHost_default_instance_;
class GameReady;
class GameReadyDefaultTypeInternal;
extern GameReadyDefaultTypeInternal _GameReady_default_instance_;
class GameRecord;
class GameRecordDefaultTypeInternal;
extern GameRecordDefaultTypeInternal _GameRecord_default_instance_;
class GameRecordList;
class GameRecordListDefaultTypeInternal;
extern GameRecordListDefaultTypeInternal _GameRecordList_default_instance_;
class GameResult;
class GameResultDefaultTypeInternal;
extern GameResultDefaultTypeInternal _GameResult_default_instance_;
class GameSuperHost;
class GameSuperHostDefaultTypeInternal;
extern GameSuperHostDefaultTypeInternal _GameSuperHost_default_instance_;
class PlayerInfo;
class PlayerInfoDefaultTypeInternal;
extern PlayerInfoDefaultTypeInternal _PlayerInfo_default_instance_;
class PlayerRecord;
class PlayerRecordDefaultTypeInternal;
extern PlayerRecordDefaultTypeInternal _PlayerRecord_default_instance_;
class UserList;
class UserListDefaultTypeInternal;
extern UserListDefaultTypeInternal _UserList_default_instance_;
}  // namespace go
namespace google {
namespace protobuf {
template<> ::go::GameBet* Arena::CreateMaybeMessage<::go::GameBet>(Arena*);
template<> ::go::GameBetResult* Arena::CreateMaybeMessage<::go::GameBetResult>(Arena*);
template<> ::go::GameHost* Arena::CreateMaybeMessage<::go::GameHost>(Arena*);
template<> ::go::GameReady* Arena::CreateMaybeMessage<::go::GameReady>(Arena*);
template<> ::go::GameRecord* Arena::CreateMaybeMessage<::go::GameRecord>(Arena*);
template<> ::go::GameRecordList* Arena::CreateMaybeMessage<::go::GameRecordList>(Arena*);
template<> ::go::GameResult* Arena::CreateMaybeMessage<::go::GameResult>(Arena*);
template<> ::go::GameSuperHost* Arena::CreateMaybeMessage<::go::GameSuperHost>(Arena*);
template<> ::go::PlayerInfo* Arena::CreateMaybeMessage<::go::PlayerInfo>(Arena*);
template<> ::go::PlayerRecord* Arena::CreateMaybeMessage<::go::PlayerRecord>(Arena*);
template<> ::go::UserList* Arena::CreateMaybeMessage<::go::UserList>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace go {

// ===================================================================

class PlayerInfo final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:go.PlayerInfo) */ {
 public:
  PlayerInfo();
  virtual ~PlayerInfo();

  PlayerInfo(const PlayerInfo& from);

  inline PlayerInfo& operator=(const PlayerInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PlayerInfo(PlayerInfo&& from) noexcept
    : PlayerInfo() {
    *this = ::std::move(from);
  }

  inline PlayerInfo& operator=(PlayerInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const PlayerInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PlayerInfo* internal_default_instance() {
    return reinterpret_cast<const PlayerInfo*>(
               &_PlayerInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(PlayerInfo* other);
  friend void swap(PlayerInfo& a, PlayerInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PlayerInfo* New() const final {
    return CreateMaybeMessage<PlayerInfo>(nullptr);
  }

  PlayerInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PlayerInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PlayerInfo& from);
  void MergeFrom(const PlayerInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string Name = 2;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // uint64 UserID = 1;
  void clear_userid();
  static const int kUserIDFieldNumber = 1;
  ::google::protobuf::uint64 userid() const;
  void set_userid(::google::protobuf::uint64 value);

  // int32 Age = 3;
  void clear_age();
  static const int kAgeFieldNumber = 3;
  ::google::protobuf::int32 age() const;
  void set_age(::google::protobuf::int32 value);

  // int32 Sex = 4;
  void clear_sex();
  static const int kSexFieldNumber = 4;
  ::google::protobuf::int32 sex() const;
  void set_sex(::google::protobuf::int32 value);

  // int64 Gold = 5;
  void clear_gold();
  static const int kGoldFieldNumber = 5;
  ::google::protobuf::int64 gold() const;
  void set_gold(::google::protobuf::int64 value);

  // int32 VipLevel = 6;
  void clear_viplevel();
  static const int kVipLevelFieldNumber = 6;
  ::google::protobuf::int32 viplevel() const;
  void set_viplevel(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:go.PlayerInfo)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::uint64 userid_;
  ::google::protobuf::int32 age_;
  ::google::protobuf::int32 sex_;
  ::google::protobuf::int64 gold_;
  ::google::protobuf::int32 viplevel_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_gamecomm_2eproto;
};
// -------------------------------------------------------------------

class UserList final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:go.UserList) */ {
 public:
  UserList();
  virtual ~UserList();

  UserList(const UserList& from);

  inline UserList& operator=(const UserList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UserList(UserList&& from) noexcept
    : UserList() {
    *this = ::std::move(from);
  }

  inline UserList& operator=(UserList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const UserList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserList* internal_default_instance() {
    return reinterpret_cast<const UserList*>(
               &_UserList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(UserList* other);
  friend void swap(UserList& a, UserList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UserList* New() const final {
    return CreateMaybeMessage<UserList>(nullptr);
  }

  UserList* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UserList>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UserList& from);
  void MergeFrom(const UserList& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .go.PlayerInfo AllInfos = 1;
  int allinfos_size() const;
  void clear_allinfos();
  static const int kAllInfosFieldNumber = 1;
  ::go::PlayerInfo* mutable_allinfos(int index);
  ::google::protobuf::RepeatedPtrField< ::go::PlayerInfo >*
      mutable_allinfos();
  const ::go::PlayerInfo& allinfos(int index) const;
  ::go::PlayerInfo* add_allinfos();
  const ::google::protobuf::RepeatedPtrField< ::go::PlayerInfo >&
      allinfos() const;

  // @@protoc_insertion_point(class_scope:go.UserList)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::go::PlayerInfo > allinfos_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_gamecomm_2eproto;
};
// -------------------------------------------------------------------

class PlayerRecord final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:go.PlayerRecord) */ {
 public:
  PlayerRecord();
  virtual ~PlayerRecord();

  PlayerRecord(const PlayerRecord& from);

  inline PlayerRecord& operator=(const PlayerRecord& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PlayerRecord(PlayerRecord&& from) noexcept
    : PlayerRecord() {
    *this = ::std::move(from);
  }

  inline PlayerRecord& operator=(PlayerRecord&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const PlayerRecord& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PlayerRecord* internal_default_instance() {
    return reinterpret_cast<const PlayerRecord*>(
               &_PlayerRecord_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(PlayerRecord* other);
  friend void swap(PlayerRecord& a, PlayerRecord& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PlayerRecord* New() const final {
    return CreateMaybeMessage<PlayerRecord>(nullptr);
  }

  PlayerRecord* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PlayerRecord>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PlayerRecord& from);
  void MergeFrom(const PlayerRecord& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerRecord* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .go.PlayerInfo User = 1;
  bool has_user() const;
  void clear_user();
  static const int kUserFieldNumber = 1;
  const ::go::PlayerInfo& user() const;
  ::go::PlayerInfo* release_user();
  ::go::PlayerInfo* mutable_user();
  void set_allocated_user(::go::PlayerInfo* user);

  // int32 Twice = 2;
  void clear_twice();
  static const int kTwiceFieldNumber = 2;
  ::google::protobuf::int32 twice() const;
  void set_twice(::google::protobuf::int32 value);

  // int32 Ranking = 3;
  void clear_ranking();
  static const int kRankingFieldNumber = 3;
  ::google::protobuf::int32 ranking() const;
  void set_ranking(::google::protobuf::int32 value);

  // int64 WinLos = 5;
  void clear_winlos();
  static const int kWinLosFieldNumber = 5;
  ::google::protobuf::int64 winlos() const;
  void set_winlos(::google::protobuf::int64 value);

  // int32 Bankroll = 4;
  void clear_bankroll();
  static const int kBankrollFieldNumber = 4;
  ::google::protobuf::int32 bankroll() const;
  void set_bankroll(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:go.PlayerRecord)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::go::PlayerInfo* user_;
  ::google::protobuf::int32 twice_;
  ::google::protobuf::int32 ranking_;
  ::google::protobuf::int64 winlos_;
  ::google::protobuf::int32 bankroll_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_gamecomm_2eproto;
};
// -------------------------------------------------------------------

class GameReady final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:go.GameReady) */ {
 public:
  GameReady();
  virtual ~GameReady();

  GameReady(const GameReady& from);

  inline GameReady& operator=(const GameReady& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GameReady(GameReady&& from) noexcept
    : GameReady() {
    *this = ::std::move(from);
  }

  inline GameReady& operator=(GameReady&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const GameReady& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GameReady* internal_default_instance() {
    return reinterpret_cast<const GameReady*>(
               &_GameReady_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(GameReady* other);
  friend void swap(GameReady& a, GameReady& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GameReady* New() const final {
    return CreateMaybeMessage<GameReady>(nullptr);
  }

  GameReady* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GameReady>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GameReady& from);
  void MergeFrom(const GameReady& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameReady* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint64 UserID = 1;
  void clear_userid();
  static const int kUserIDFieldNumber = 1;
  ::google::protobuf::uint64 userid() const;
  void set_userid(::google::protobuf::uint64 value);

  // bool IsReady = 2;
  void clear_isready();
  static const int kIsReadyFieldNumber = 2;
  bool isready() const;
  void set_isready(bool value);

  // @@protoc_insertion_point(class_scope:go.GameReady)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint64 userid_;
  bool isready_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_gamecomm_2eproto;
};
// -------------------------------------------------------------------

class GameBet final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:go.GameBet) */ {
 public:
  GameBet();
  virtual ~GameBet();

  GameBet(const GameBet& from);

  inline GameBet& operator=(const GameBet& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GameBet(GameBet&& from) noexcept
    : GameBet() {
    *this = ::std::move(from);
  }

  inline GameBet& operator=(GameBet&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const GameBet& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GameBet* internal_default_instance() {
    return reinterpret_cast<const GameBet*>(
               &_GameBet_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(GameBet* other);
  friend void swap(GameBet& a, GameBet& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GameBet* New() const final {
    return CreateMaybeMessage<GameBet>(nullptr);
  }

  GameBet* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GameBet>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GameBet& from);
  void MergeFrom(const GameBet& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameBet* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int64 BetScore = 2;
  void clear_betscore();
  static const int kBetScoreFieldNumber = 2;
  ::google::protobuf::int64 betscore() const;
  void set_betscore(::google::protobuf::int64 value);

  // int32 BetArea = 1;
  void clear_betarea();
  static const int kBetAreaFieldNumber = 1;
  ::google::protobuf::int32 betarea() const;
  void set_betarea(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:go.GameBet)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int64 betscore_;
  ::google::protobuf::int32 betarea_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_gamecomm_2eproto;
};
// -------------------------------------------------------------------

class GameBetResult final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:go.GameBetResult) */ {
 public:
  GameBetResult();
  virtual ~GameBetResult();

  GameBetResult(const GameBetResult& from);

  inline GameBetResult& operator=(const GameBetResult& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GameBetResult(GameBetResult&& from) noexcept
    : GameBetResult() {
    *this = ::std::move(from);
  }

  inline GameBetResult& operator=(GameBetResult&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const GameBetResult& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GameBetResult* internal_default_instance() {
    return reinterpret_cast<const GameBetResult*>(
               &_GameBetResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(GameBetResult* other);
  friend void swap(GameBetResult& a, GameBetResult& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GameBetResult* New() const final {
    return CreateMaybeMessage<GameBetResult>(nullptr);
  }

  GameBetResult* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GameBetResult>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GameBetResult& from);
  void MergeFrom(const GameBetResult& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameBetResult* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string Hints = 3;
  void clear_hints();
  static const int kHintsFieldNumber = 3;
  const ::std::string& hints() const;
  void set_hints(const ::std::string& value);
  #if LANG_CXX11
  void set_hints(::std::string&& value);
  #endif
  void set_hints(const char* value);
  void set_hints(const char* value, size_t size);
  ::std::string* mutable_hints();
  ::std::string* release_hints();
  void set_allocated_hints(::std::string* hints);

  // uint64 UserID = 1;
  void clear_userid();
  static const int kUserIDFieldNumber = 1;
  ::google::protobuf::uint64 userid() const;
  void set_userid(::google::protobuf::uint64 value);

  // int32 State = 2;
  void clear_state();
  static const int kStateFieldNumber = 2;
  ::google::protobuf::int32 state() const;
  void set_state(::google::protobuf::int32 value);

  // int32 BetArea = 4;
  void clear_betarea();
  static const int kBetAreaFieldNumber = 4;
  ::google::protobuf::int32 betarea() const;
  void set_betarea(::google::protobuf::int32 value);

  // int64 BetScore = 5;
  void clear_betscore();
  static const int kBetScoreFieldNumber = 5;
  ::google::protobuf::int64 betscore() const;
  void set_betscore(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:go.GameBetResult)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr hints_;
  ::google::protobuf::uint64 userid_;
  ::google::protobuf::int32 state_;
  ::google::protobuf::int32 betarea_;
  ::google::protobuf::int64 betscore_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_gamecomm_2eproto;
};
// -------------------------------------------------------------------

class GameHost final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:go.GameHost) */ {
 public:
  GameHost();
  virtual ~GameHost();

  GameHost(const GameHost& from);

  inline GameHost& operator=(const GameHost& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GameHost(GameHost&& from) noexcept
    : GameHost() {
    *this = ::std::move(from);
  }

  inline GameHost& operator=(GameHost&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const GameHost& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GameHost* internal_default_instance() {
    return reinterpret_cast<const GameHost*>(
               &_GameHost_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(GameHost* other);
  friend void swap(GameHost& a, GameHost& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GameHost* New() const final {
    return CreateMaybeMessage<GameHost>(nullptr);
  }

  GameHost* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GameHost>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GameHost& from);
  void MergeFrom(const GameHost& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameHost* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bool IsWant = 1;
  void clear_iswant();
  static const int kIsWantFieldNumber = 1;
  bool iswant() const;
  void set_iswant(bool value);

  // @@protoc_insertion_point(class_scope:go.GameHost)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool iswant_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_gamecomm_2eproto;
};
// -------------------------------------------------------------------

class GameSuperHost final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:go.GameSuperHost) */ {
 public:
  GameSuperHost();
  virtual ~GameSuperHost();

  GameSuperHost(const GameSuperHost& from);

  inline GameSuperHost& operator=(const GameSuperHost& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GameSuperHost(GameSuperHost&& from) noexcept
    : GameSuperHost() {
    *this = ::std::move(from);
  }

  inline GameSuperHost& operator=(GameSuperHost&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const GameSuperHost& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GameSuperHost* internal_default_instance() {
    return reinterpret_cast<const GameSuperHost*>(
               &_GameSuperHost_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(GameSuperHost* other);
  friend void swap(GameSuperHost& a, GameSuperHost& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GameSuperHost* New() const final {
    return CreateMaybeMessage<GameSuperHost>(nullptr);
  }

  GameSuperHost* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GameSuperHost>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GameSuperHost& from);
  void MergeFrom(const GameSuperHost& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameSuperHost* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bool IsWant = 1;
  void clear_iswant();
  static const int kIsWantFieldNumber = 1;
  bool iswant() const;
  void set_iswant(bool value);

  // @@protoc_insertion_point(class_scope:go.GameSuperHost)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool iswant_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_gamecomm_2eproto;
};
// -------------------------------------------------------------------

class GameRecord final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:go.GameRecord) */ {
 public:
  GameRecord();
  virtual ~GameRecord();

  GameRecord(const GameRecord& from);

  inline GameRecord& operator=(const GameRecord& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GameRecord(GameRecord&& from) noexcept
    : GameRecord() {
    *this = ::std::move(from);
  }

  inline GameRecord& operator=(GameRecord&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const GameRecord& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GameRecord* internal_default_instance() {
    return reinterpret_cast<const GameRecord*>(
               &_GameRecord_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(GameRecord* other);
  friend void swap(GameRecord& a, GameRecord& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GameRecord* New() const final {
    return CreateMaybeMessage<GameRecord>(nullptr);
  }

  GameRecord* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GameRecord>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GameRecord& from);
  void MergeFrom(const GameRecord& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameRecord* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes Pork = 1;
  void clear_pork();
  static const int kPorkFieldNumber = 1;
  const ::std::string& pork() const;
  void set_pork(const ::std::string& value);
  #if LANG_CXX11
  void set_pork(::std::string&& value);
  #endif
  void set_pork(const char* value);
  void set_pork(const void* value, size_t size);
  ::std::string* mutable_pork();
  ::std::string* release_pork();
  void set_allocated_pork(::std::string* pork);

  // int32 Type = 2;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::google::protobuf::int32 type() const;
  void set_type(::google::protobuf::int32 value);

  // bool isWon = 3;
  void clear_iswon();
  static const int kIsWonFieldNumber = 3;
  bool iswon() const;
  void set_iswon(bool value);

  // @@protoc_insertion_point(class_scope:go.GameRecord)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr pork_;
  ::google::protobuf::int32 type_;
  bool iswon_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_gamecomm_2eproto;
};
// -------------------------------------------------------------------

class GameRecordList final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:go.GameRecordList) */ {
 public:
  GameRecordList();
  virtual ~GameRecordList();

  GameRecordList(const GameRecordList& from);

  inline GameRecordList& operator=(const GameRecordList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GameRecordList(GameRecordList&& from) noexcept
    : GameRecordList() {
    *this = ::std::move(from);
  }

  inline GameRecordList& operator=(GameRecordList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const GameRecordList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GameRecordList* internal_default_instance() {
    return reinterpret_cast<const GameRecordList*>(
               &_GameRecordList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(GameRecordList* other);
  friend void swap(GameRecordList& a, GameRecordList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GameRecordList* New() const final {
    return CreateMaybeMessage<GameRecordList>(nullptr);
  }

  GameRecordList* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GameRecordList>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GameRecordList& from);
  void MergeFrom(const GameRecordList& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameRecordList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .go.GameRecord list = 1;
  int list_size() const;
  void clear_list();
  static const int kListFieldNumber = 1;
  ::go::GameRecord* mutable_list(int index);
  ::google::protobuf::RepeatedPtrField< ::go::GameRecord >*
      mutable_list();
  const ::go::GameRecord& list(int index) const;
  ::go::GameRecord* add_list();
  const ::google::protobuf::RepeatedPtrField< ::go::GameRecord >&
      list() const;

  // @@protoc_insertion_point(class_scope:go.GameRecordList)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::go::GameRecord > list_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_gamecomm_2eproto;
};
// -------------------------------------------------------------------

class GameResult final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:go.GameResult) */ {
 public:
  GameResult();
  virtual ~GameResult();

  GameResult(const GameResult& from);

  inline GameResult& operator=(const GameResult& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GameResult(GameResult&& from) noexcept
    : GameResult() {
    *this = ::std::move(from);
  }

  inline GameResult& operator=(GameResult&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const GameResult& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GameResult* internal_default_instance() {
    return reinterpret_cast<const GameResult*>(
               &_GameResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(GameResult* other);
  friend void swap(GameResult& a, GameResult& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GameResult* New() const final {
    return CreateMaybeMessage<GameResult>(nullptr);
  }

  GameResult* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GameResult>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GameResult& from);
  void MergeFrom(const GameResult& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameResult* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes Reason = 2;
  void clear_reason();
  static const int kReasonFieldNumber = 2;
  const ::std::string& reason() const;
  void set_reason(const ::std::string& value);
  #if LANG_CXX11
  void set_reason(::std::string&& value);
  #endif
  void set_reason(const char* value);
  void set_reason(const void* value, size_t size);
  ::std::string* mutable_reason();
  ::std::string* release_reason();
  void set_allocated_reason(::std::string* reason);

  // int32 Flag = 1;
  void clear_flag();
  static const int kFlagFieldNumber = 1;
  ::google::protobuf::int32 flag() const;
  void set_flag(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:go.GameResult)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr reason_;
  ::google::protobuf::int32 flag_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_gamecomm_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// PlayerInfo

// uint64 UserID = 1;
inline void PlayerInfo::clear_userid() {
  userid_ = PROTOBUF_ULONGLONG(0);
}
inline ::google::protobuf::uint64 PlayerInfo::userid() const {
  // @@protoc_insertion_point(field_get:go.PlayerInfo.UserID)
  return userid_;
}
inline void PlayerInfo::set_userid(::google::protobuf::uint64 value) {
  
  userid_ = value;
  // @@protoc_insertion_point(field_set:go.PlayerInfo.UserID)
}

// string Name = 2;
inline void PlayerInfo::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PlayerInfo::name() const {
  // @@protoc_insertion_point(field_get:go.PlayerInfo.Name)
  return name_.GetNoArena();
}
inline void PlayerInfo::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:go.PlayerInfo.Name)
}
#if LANG_CXX11
inline void PlayerInfo::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:go.PlayerInfo.Name)
}
#endif
inline void PlayerInfo::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:go.PlayerInfo.Name)
}
inline void PlayerInfo::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:go.PlayerInfo.Name)
}
inline ::std::string* PlayerInfo::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:go.PlayerInfo.Name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PlayerInfo::release_name() {
  // @@protoc_insertion_point(field_release:go.PlayerInfo.Name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PlayerInfo::set_allocated_name(::std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:go.PlayerInfo.Name)
}

// int32 Age = 3;
inline void PlayerInfo::clear_age() {
  age_ = 0;
}
inline ::google::protobuf::int32 PlayerInfo::age() const {
  // @@protoc_insertion_point(field_get:go.PlayerInfo.Age)
  return age_;
}
inline void PlayerInfo::set_age(::google::protobuf::int32 value) {
  
  age_ = value;
  // @@protoc_insertion_point(field_set:go.PlayerInfo.Age)
}

// int32 Sex = 4;
inline void PlayerInfo::clear_sex() {
  sex_ = 0;
}
inline ::google::protobuf::int32 PlayerInfo::sex() const {
  // @@protoc_insertion_point(field_get:go.PlayerInfo.Sex)
  return sex_;
}
inline void PlayerInfo::set_sex(::google::protobuf::int32 value) {
  
  sex_ = value;
  // @@protoc_insertion_point(field_set:go.PlayerInfo.Sex)
}

// int64 Gold = 5;
inline void PlayerInfo::clear_gold() {
  gold_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 PlayerInfo::gold() const {
  // @@protoc_insertion_point(field_get:go.PlayerInfo.Gold)
  return gold_;
}
inline void PlayerInfo::set_gold(::google::protobuf::int64 value) {
  
  gold_ = value;
  // @@protoc_insertion_point(field_set:go.PlayerInfo.Gold)
}

// int32 VipLevel = 6;
inline void PlayerInfo::clear_viplevel() {
  viplevel_ = 0;
}
inline ::google::protobuf::int32 PlayerInfo::viplevel() const {
  // @@protoc_insertion_point(field_get:go.PlayerInfo.VipLevel)
  return viplevel_;
}
inline void PlayerInfo::set_viplevel(::google::protobuf::int32 value) {
  
  viplevel_ = value;
  // @@protoc_insertion_point(field_set:go.PlayerInfo.VipLevel)
}

// -------------------------------------------------------------------

// UserList

// repeated .go.PlayerInfo AllInfos = 1;
inline int UserList::allinfos_size() const {
  return allinfos_.size();
}
inline void UserList::clear_allinfos() {
  allinfos_.Clear();
}
inline ::go::PlayerInfo* UserList::mutable_allinfos(int index) {
  // @@protoc_insertion_point(field_mutable:go.UserList.AllInfos)
  return allinfos_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::go::PlayerInfo >*
UserList::mutable_allinfos() {
  // @@protoc_insertion_point(field_mutable_list:go.UserList.AllInfos)
  return &allinfos_;
}
inline const ::go::PlayerInfo& UserList::allinfos(int index) const {
  // @@protoc_insertion_point(field_get:go.UserList.AllInfos)
  return allinfos_.Get(index);
}
inline ::go::PlayerInfo* UserList::add_allinfos() {
  // @@protoc_insertion_point(field_add:go.UserList.AllInfos)
  return allinfos_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::go::PlayerInfo >&
UserList::allinfos() const {
  // @@protoc_insertion_point(field_list:go.UserList.AllInfos)
  return allinfos_;
}

// -------------------------------------------------------------------

// PlayerRecord

// .go.PlayerInfo User = 1;
inline bool PlayerRecord::has_user() const {
  return this != internal_default_instance() && user_ != nullptr;
}
inline void PlayerRecord::clear_user() {
  if (GetArenaNoVirtual() == nullptr && user_ != nullptr) {
    delete user_;
  }
  user_ = nullptr;
}
inline const ::go::PlayerInfo& PlayerRecord::user() const {
  const ::go::PlayerInfo* p = user_;
  // @@protoc_insertion_point(field_get:go.PlayerRecord.User)
  return p != nullptr ? *p : *reinterpret_cast<const ::go::PlayerInfo*>(
      &::go::_PlayerInfo_default_instance_);
}
inline ::go::PlayerInfo* PlayerRecord::release_user() {
  // @@protoc_insertion_point(field_release:go.PlayerRecord.User)
  
  ::go::PlayerInfo* temp = user_;
  user_ = nullptr;
  return temp;
}
inline ::go::PlayerInfo* PlayerRecord::mutable_user() {
  
  if (user_ == nullptr) {
    auto* p = CreateMaybeMessage<::go::PlayerInfo>(GetArenaNoVirtual());
    user_ = p;
  }
  // @@protoc_insertion_point(field_mutable:go.PlayerRecord.User)
  return user_;
}
inline void PlayerRecord::set_allocated_user(::go::PlayerInfo* user) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete user_;
  }
  if (user) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      user = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, user, submessage_arena);
    }
    
  } else {
    
  }
  user_ = user;
  // @@protoc_insertion_point(field_set_allocated:go.PlayerRecord.User)
}

// int32 Twice = 2;
inline void PlayerRecord::clear_twice() {
  twice_ = 0;
}
inline ::google::protobuf::int32 PlayerRecord::twice() const {
  // @@protoc_insertion_point(field_get:go.PlayerRecord.Twice)
  return twice_;
}
inline void PlayerRecord::set_twice(::google::protobuf::int32 value) {
  
  twice_ = value;
  // @@protoc_insertion_point(field_set:go.PlayerRecord.Twice)
}

// int32 Ranking = 3;
inline void PlayerRecord::clear_ranking() {
  ranking_ = 0;
}
inline ::google::protobuf::int32 PlayerRecord::ranking() const {
  // @@protoc_insertion_point(field_get:go.PlayerRecord.Ranking)
  return ranking_;
}
inline void PlayerRecord::set_ranking(::google::protobuf::int32 value) {
  
  ranking_ = value;
  // @@protoc_insertion_point(field_set:go.PlayerRecord.Ranking)
}

// int32 Bankroll = 4;
inline void PlayerRecord::clear_bankroll() {
  bankroll_ = 0;
}
inline ::google::protobuf::int32 PlayerRecord::bankroll() const {
  // @@protoc_insertion_point(field_get:go.PlayerRecord.Bankroll)
  return bankroll_;
}
inline void PlayerRecord::set_bankroll(::google::protobuf::int32 value) {
  
  bankroll_ = value;
  // @@protoc_insertion_point(field_set:go.PlayerRecord.Bankroll)
}

// int64 WinLos = 5;
inline void PlayerRecord::clear_winlos() {
  winlos_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 PlayerRecord::winlos() const {
  // @@protoc_insertion_point(field_get:go.PlayerRecord.WinLos)
  return winlos_;
}
inline void PlayerRecord::set_winlos(::google::protobuf::int64 value) {
  
  winlos_ = value;
  // @@protoc_insertion_point(field_set:go.PlayerRecord.WinLos)
}

// -------------------------------------------------------------------

// GameReady

// uint64 UserID = 1;
inline void GameReady::clear_userid() {
  userid_ = PROTOBUF_ULONGLONG(0);
}
inline ::google::protobuf::uint64 GameReady::userid() const {
  // @@protoc_insertion_point(field_get:go.GameReady.UserID)
  return userid_;
}
inline void GameReady::set_userid(::google::protobuf::uint64 value) {
  
  userid_ = value;
  // @@protoc_insertion_point(field_set:go.GameReady.UserID)
}

// bool IsReady = 2;
inline void GameReady::clear_isready() {
  isready_ = false;
}
inline bool GameReady::isready() const {
  // @@protoc_insertion_point(field_get:go.GameReady.IsReady)
  return isready_;
}
inline void GameReady::set_isready(bool value) {
  
  isready_ = value;
  // @@protoc_insertion_point(field_set:go.GameReady.IsReady)
}

// -------------------------------------------------------------------

// GameBet

// int32 BetArea = 1;
inline void GameBet::clear_betarea() {
  betarea_ = 0;
}
inline ::google::protobuf::int32 GameBet::betarea() const {
  // @@protoc_insertion_point(field_get:go.GameBet.BetArea)
  return betarea_;
}
inline void GameBet::set_betarea(::google::protobuf::int32 value) {
  
  betarea_ = value;
  // @@protoc_insertion_point(field_set:go.GameBet.BetArea)
}

// int64 BetScore = 2;
inline void GameBet::clear_betscore() {
  betscore_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 GameBet::betscore() const {
  // @@protoc_insertion_point(field_get:go.GameBet.BetScore)
  return betscore_;
}
inline void GameBet::set_betscore(::google::protobuf::int64 value) {
  
  betscore_ = value;
  // @@protoc_insertion_point(field_set:go.GameBet.BetScore)
}

// -------------------------------------------------------------------

// GameBetResult

// uint64 UserID = 1;
inline void GameBetResult::clear_userid() {
  userid_ = PROTOBUF_ULONGLONG(0);
}
inline ::google::protobuf::uint64 GameBetResult::userid() const {
  // @@protoc_insertion_point(field_get:go.GameBetResult.UserID)
  return userid_;
}
inline void GameBetResult::set_userid(::google::protobuf::uint64 value) {
  
  userid_ = value;
  // @@protoc_insertion_point(field_set:go.GameBetResult.UserID)
}

// int32 State = 2;
inline void GameBetResult::clear_state() {
  state_ = 0;
}
inline ::google::protobuf::int32 GameBetResult::state() const {
  // @@protoc_insertion_point(field_get:go.GameBetResult.State)
  return state_;
}
inline void GameBetResult::set_state(::google::protobuf::int32 value) {
  
  state_ = value;
  // @@protoc_insertion_point(field_set:go.GameBetResult.State)
}

// string Hints = 3;
inline void GameBetResult::clear_hints() {
  hints_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GameBetResult::hints() const {
  // @@protoc_insertion_point(field_get:go.GameBetResult.Hints)
  return hints_.GetNoArena();
}
inline void GameBetResult::set_hints(const ::std::string& value) {
  
  hints_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:go.GameBetResult.Hints)
}
#if LANG_CXX11
inline void GameBetResult::set_hints(::std::string&& value) {
  
  hints_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:go.GameBetResult.Hints)
}
#endif
inline void GameBetResult::set_hints(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  hints_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:go.GameBetResult.Hints)
}
inline void GameBetResult::set_hints(const char* value, size_t size) {
  
  hints_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:go.GameBetResult.Hints)
}
inline ::std::string* GameBetResult::mutable_hints() {
  
  // @@protoc_insertion_point(field_mutable:go.GameBetResult.Hints)
  return hints_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GameBetResult::release_hints() {
  // @@protoc_insertion_point(field_release:go.GameBetResult.Hints)
  
  return hints_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GameBetResult::set_allocated_hints(::std::string* hints) {
  if (hints != nullptr) {
    
  } else {
    
  }
  hints_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hints);
  // @@protoc_insertion_point(field_set_allocated:go.GameBetResult.Hints)
}

// int32 BetArea = 4;
inline void GameBetResult::clear_betarea() {
  betarea_ = 0;
}
inline ::google::protobuf::int32 GameBetResult::betarea() const {
  // @@protoc_insertion_point(field_get:go.GameBetResult.BetArea)
  return betarea_;
}
inline void GameBetResult::set_betarea(::google::protobuf::int32 value) {
  
  betarea_ = value;
  // @@protoc_insertion_point(field_set:go.GameBetResult.BetArea)
}

// int64 BetScore = 5;
inline void GameBetResult::clear_betscore() {
  betscore_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 GameBetResult::betscore() const {
  // @@protoc_insertion_point(field_get:go.GameBetResult.BetScore)
  return betscore_;
}
inline void GameBetResult::set_betscore(::google::protobuf::int64 value) {
  
  betscore_ = value;
  // @@protoc_insertion_point(field_set:go.GameBetResult.BetScore)
}

// -------------------------------------------------------------------

// GameHost

// bool IsWant = 1;
inline void GameHost::clear_iswant() {
  iswant_ = false;
}
inline bool GameHost::iswant() const {
  // @@protoc_insertion_point(field_get:go.GameHost.IsWant)
  return iswant_;
}
inline void GameHost::set_iswant(bool value) {
  
  iswant_ = value;
  // @@protoc_insertion_point(field_set:go.GameHost.IsWant)
}

// -------------------------------------------------------------------

// GameSuperHost

// bool IsWant = 1;
inline void GameSuperHost::clear_iswant() {
  iswant_ = false;
}
inline bool GameSuperHost::iswant() const {
  // @@protoc_insertion_point(field_get:go.GameSuperHost.IsWant)
  return iswant_;
}
inline void GameSuperHost::set_iswant(bool value) {
  
  iswant_ = value;
  // @@protoc_insertion_point(field_set:go.GameSuperHost.IsWant)
}

// -------------------------------------------------------------------

// GameRecord

// bytes Pork = 1;
inline void GameRecord::clear_pork() {
  pork_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GameRecord::pork() const {
  // @@protoc_insertion_point(field_get:go.GameRecord.Pork)
  return pork_.GetNoArena();
}
inline void GameRecord::set_pork(const ::std::string& value) {
  
  pork_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:go.GameRecord.Pork)
}
#if LANG_CXX11
inline void GameRecord::set_pork(::std::string&& value) {
  
  pork_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:go.GameRecord.Pork)
}
#endif
inline void GameRecord::set_pork(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  pork_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:go.GameRecord.Pork)
}
inline void GameRecord::set_pork(const void* value, size_t size) {
  
  pork_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:go.GameRecord.Pork)
}
inline ::std::string* GameRecord::mutable_pork() {
  
  // @@protoc_insertion_point(field_mutable:go.GameRecord.Pork)
  return pork_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GameRecord::release_pork() {
  // @@protoc_insertion_point(field_release:go.GameRecord.Pork)
  
  return pork_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GameRecord::set_allocated_pork(::std::string* pork) {
  if (pork != nullptr) {
    
  } else {
    
  }
  pork_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pork);
  // @@protoc_insertion_point(field_set_allocated:go.GameRecord.Pork)
}

// int32 Type = 2;
inline void GameRecord::clear_type() {
  type_ = 0;
}
inline ::google::protobuf::int32 GameRecord::type() const {
  // @@protoc_insertion_point(field_get:go.GameRecord.Type)
  return type_;
}
inline void GameRecord::set_type(::google::protobuf::int32 value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:go.GameRecord.Type)
}

// bool isWon = 3;
inline void GameRecord::clear_iswon() {
  iswon_ = false;
}
inline bool GameRecord::iswon() const {
  // @@protoc_insertion_point(field_get:go.GameRecord.isWon)
  return iswon_;
}
inline void GameRecord::set_iswon(bool value) {
  
  iswon_ = value;
  // @@protoc_insertion_point(field_set:go.GameRecord.isWon)
}

// -------------------------------------------------------------------

// GameRecordList

// repeated .go.GameRecord list = 1;
inline int GameRecordList::list_size() const {
  return list_.size();
}
inline void GameRecordList::clear_list() {
  list_.Clear();
}
inline ::go::GameRecord* GameRecordList::mutable_list(int index) {
  // @@protoc_insertion_point(field_mutable:go.GameRecordList.list)
  return list_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::go::GameRecord >*
GameRecordList::mutable_list() {
  // @@protoc_insertion_point(field_mutable_list:go.GameRecordList.list)
  return &list_;
}
inline const ::go::GameRecord& GameRecordList::list(int index) const {
  // @@protoc_insertion_point(field_get:go.GameRecordList.list)
  return list_.Get(index);
}
inline ::go::GameRecord* GameRecordList::add_list() {
  // @@protoc_insertion_point(field_add:go.GameRecordList.list)
  return list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::go::GameRecord >&
GameRecordList::list() const {
  // @@protoc_insertion_point(field_list:go.GameRecordList.list)
  return list_;
}

// -------------------------------------------------------------------

// GameResult

// int32 Flag = 1;
inline void GameResult::clear_flag() {
  flag_ = 0;
}
inline ::google::protobuf::int32 GameResult::flag() const {
  // @@protoc_insertion_point(field_get:go.GameResult.Flag)
  return flag_;
}
inline void GameResult::set_flag(::google::protobuf::int32 value) {
  
  flag_ = value;
  // @@protoc_insertion_point(field_set:go.GameResult.Flag)
}

// bytes Reason = 2;
inline void GameResult::clear_reason() {
  reason_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GameResult::reason() const {
  // @@protoc_insertion_point(field_get:go.GameResult.Reason)
  return reason_.GetNoArena();
}
inline void GameResult::set_reason(const ::std::string& value) {
  
  reason_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:go.GameResult.Reason)
}
#if LANG_CXX11
inline void GameResult::set_reason(::std::string&& value) {
  
  reason_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:go.GameResult.Reason)
}
#endif
inline void GameResult::set_reason(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  reason_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:go.GameResult.Reason)
}
inline void GameResult::set_reason(const void* value, size_t size) {
  
  reason_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:go.GameResult.Reason)
}
inline ::std::string* GameResult::mutable_reason() {
  
  // @@protoc_insertion_point(field_mutable:go.GameResult.Reason)
  return reason_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GameResult::release_reason() {
  // @@protoc_insertion_point(field_release:go.GameResult.Reason)
  
  return reason_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GameResult::set_allocated_reason(::std::string* reason) {
  if (reason != nullptr) {
    
  } else {
    
  }
  reason_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), reason);
  // @@protoc_insertion_point(field_set_allocated:go.GameResult.Reason)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace go

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // PROTOBUF_INCLUDED_gamecomm_2eproto
