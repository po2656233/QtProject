// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: login.proto

#ifndef PROTOBUF_INCLUDED_login_2eproto
#define PROTOBUF_INCLUDED_login_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3007000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3007000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_login_2eproto

// Internal implementation detail -- do not use these members.
struct TableStruct_login_2eproto {
  static const ::google::protobuf::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::ParseTable schema[15]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors_login_2eproto();
namespace go {
class GameBaseInfo;
class GameBaseInfoDefaultTypeInternal;
extern GameBaseInfoDefaultTypeInternal _GameBaseInfo_default_instance_;
class GameItem;
class GameItemDefaultTypeInternal;
extern GameItemDefaultTypeInternal _GameItem_default_instance_;
class GameList;
class GameListDefaultTypeInternal;
extern GameListDefaultTypeInternal _GameList_default_instance_;
class Login;
class LoginDefaultTypeInternal;
extern LoginDefaultTypeInternal _Login_default_instance_;
class MasterInfo;
class MasterInfoDefaultTypeInternal;
extern MasterInfoDefaultTypeInternal _MasterInfo_default_instance_;
class Register;
class RegisterDefaultTypeInternal;
extern RegisterDefaultTypeInternal _Register_default_instance_;
class RegisterResult;
class RegisterResultDefaultTypeInternal;
extern RegisterResultDefaultTypeInternal _RegisterResult_default_instance_;
class ReqEnterGame;
class ReqEnterGameDefaultTypeInternal;
extern ReqEnterGameDefaultTypeInternal _ReqEnterGame_default_instance_;
class ReqEnterRoom;
class ReqEnterRoomDefaultTypeInternal;
extern ReqEnterRoomDefaultTypeInternal _ReqEnterRoom_default_instance_;
class ReqExitGame;
class ReqExitGameDefaultTypeInternal;
extern ReqExitGameDefaultTypeInternal _ReqExitGame_default_instance_;
class ResResult;
class ResResultDefaultTypeInternal;
extern ResResultDefaultTypeInternal _ResResult_default_instance_;
class RoomInfo;
class RoomInfoDefaultTypeInternal;
extern RoomInfoDefaultTypeInternal _RoomInfo_default_instance_;
class TaskItem;
class TaskItemDefaultTypeInternal;
extern TaskItemDefaultTypeInternal _TaskItem_default_instance_;
class TaskList;
class TaskListDefaultTypeInternal;
extern TaskListDefaultTypeInternal _TaskList_default_instance_;
class UserInfo;
class UserInfoDefaultTypeInternal;
extern UserInfoDefaultTypeInternal _UserInfo_default_instance_;
}  // namespace go
namespace google {
namespace protobuf {
template<> ::go::GameBaseInfo* Arena::CreateMaybeMessage<::go::GameBaseInfo>(Arena*);
template<> ::go::GameItem* Arena::CreateMaybeMessage<::go::GameItem>(Arena*);
template<> ::go::GameList* Arena::CreateMaybeMessage<::go::GameList>(Arena*);
template<> ::go::Login* Arena::CreateMaybeMessage<::go::Login>(Arena*);
template<> ::go::MasterInfo* Arena::CreateMaybeMessage<::go::MasterInfo>(Arena*);
template<> ::go::Register* Arena::CreateMaybeMessage<::go::Register>(Arena*);
template<> ::go::RegisterResult* Arena::CreateMaybeMessage<::go::RegisterResult>(Arena*);
template<> ::go::ReqEnterGame* Arena::CreateMaybeMessage<::go::ReqEnterGame>(Arena*);
template<> ::go::ReqEnterRoom* Arena::CreateMaybeMessage<::go::ReqEnterRoom>(Arena*);
template<> ::go::ReqExitGame* Arena::CreateMaybeMessage<::go::ReqExitGame>(Arena*);
template<> ::go::ResResult* Arena::CreateMaybeMessage<::go::ResResult>(Arena*);
template<> ::go::RoomInfo* Arena::CreateMaybeMessage<::go::RoomInfo>(Arena*);
template<> ::go::TaskItem* Arena::CreateMaybeMessage<::go::TaskItem>(Arena*);
template<> ::go::TaskList* Arena::CreateMaybeMessage<::go::TaskList>(Arena*);
template<> ::go::UserInfo* Arena::CreateMaybeMessage<::go::UserInfo>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace go {

// ===================================================================

class Register final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:go.Register) */ {
 public:
  Register();
  virtual ~Register();

  Register(const Register& from);

  inline Register& operator=(const Register& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Register(Register&& from) noexcept
    : Register() {
    *this = ::std::move(from);
  }

  inline Register& operator=(Register&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Register& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Register* internal_default_instance() {
    return reinterpret_cast<const Register*>(
               &_Register_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Register* other);
  friend void swap(Register& a, Register& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Register* New() const final {
    return CreateMaybeMessage<Register>(nullptr);
  }

  Register* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Register>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Register& from);
  void MergeFrom(const Register& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Register* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string Name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string Password = 2;
  void clear_password();
  static const int kPasswordFieldNumber = 2;
  const ::std::string& password() const;
  void set_password(const ::std::string& value);
  #if LANG_CXX11
  void set_password(::std::string&& value);
  #endif
  void set_password(const char* value);
  void set_password(const char* value, size_t size);
  ::std::string* mutable_password();
  ::std::string* release_password();
  void set_allocated_password(::std::string* password);

  // string SecurityCode = 3;
  void clear_securitycode();
  static const int kSecurityCodeFieldNumber = 3;
  const ::std::string& securitycode() const;
  void set_securitycode(const ::std::string& value);
  #if LANG_CXX11
  void set_securitycode(::std::string&& value);
  #endif
  void set_securitycode(const char* value);
  void set_securitycode(const char* value, size_t size);
  ::std::string* mutable_securitycode();
  ::std::string* release_securitycode();
  void set_allocated_securitycode(::std::string* securitycode);

  // string MachineCode = 4;
  void clear_machinecode();
  static const int kMachineCodeFieldNumber = 4;
  const ::std::string& machinecode() const;
  void set_machinecode(const ::std::string& value);
  #if LANG_CXX11
  void set_machinecode(::std::string&& value);
  #endif
  void set_machinecode(const char* value);
  void set_machinecode(const char* value, size_t size);
  ::std::string* mutable_machinecode();
  ::std::string* release_machinecode();
  void set_allocated_machinecode(::std::string* machinecode);

  // string InvitationCode = 5;
  void clear_invitationcode();
  static const int kInvitationCodeFieldNumber = 5;
  const ::std::string& invitationcode() const;
  void set_invitationcode(const ::std::string& value);
  #if LANG_CXX11
  void set_invitationcode(::std::string&& value);
  #endif
  void set_invitationcode(const char* value);
  void set_invitationcode(const char* value, size_t size);
  ::std::string* mutable_invitationcode();
  ::std::string* release_invitationcode();
  void set_allocated_invitationcode(::std::string* invitationcode);

  // @@protoc_insertion_point(class_scope:go.Register)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr password_;
  ::google::protobuf::internal::ArenaStringPtr securitycode_;
  ::google::protobuf::internal::ArenaStringPtr machinecode_;
  ::google::protobuf::internal::ArenaStringPtr invitationcode_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_login_2eproto;
};
// -------------------------------------------------------------------

class RegisterResult final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:go.RegisterResult) */ {
 public:
  RegisterResult();
  virtual ~RegisterResult();

  RegisterResult(const RegisterResult& from);

  inline RegisterResult& operator=(const RegisterResult& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RegisterResult(RegisterResult&& from) noexcept
    : RegisterResult() {
    *this = ::std::move(from);
  }

  inline RegisterResult& operator=(RegisterResult&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const RegisterResult& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RegisterResult* internal_default_instance() {
    return reinterpret_cast<const RegisterResult*>(
               &_RegisterResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(RegisterResult* other);
  friend void swap(RegisterResult& a, RegisterResult& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RegisterResult* New() const final {
    return CreateMaybeMessage<RegisterResult>(nullptr);
  }

  RegisterResult* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RegisterResult>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RegisterResult& from);
  void MergeFrom(const RegisterResult& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegisterResult* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string Hints = 2;
  void clear_hints();
  static const int kHintsFieldNumber = 2;
  const ::std::string& hints() const;
  void set_hints(const ::std::string& value);
  #if LANG_CXX11
  void set_hints(::std::string&& value);
  #endif
  void set_hints(const char* value);
  void set_hints(const char* value, size_t size);
  ::std::string* mutable_hints();
  ::std::string* release_hints();
  void set_allocated_hints(::std::string* hints);

  // uint32 State = 1;
  void clear_state();
  static const int kStateFieldNumber = 1;
  ::google::protobuf::uint32 state() const;
  void set_state(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:go.RegisterResult)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr hints_;
  ::google::protobuf::uint32 state_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_login_2eproto;
};
// -------------------------------------------------------------------

class Login final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:go.Login) */ {
 public:
  Login();
  virtual ~Login();

  Login(const Login& from);

  inline Login& operator=(const Login& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Login(Login&& from) noexcept
    : Login() {
    *this = ::std::move(from);
  }

  inline Login& operator=(Login&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Login& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Login* internal_default_instance() {
    return reinterpret_cast<const Login*>(
               &_Login_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(Login* other);
  friend void swap(Login& a, Login& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Login* New() const final {
    return CreateMaybeMessage<Login>(nullptr);
  }

  Login* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Login>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Login& from);
  void MergeFrom(const Login& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Login* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string Account = 1;
  void clear_account();
  static const int kAccountFieldNumber = 1;
  const ::std::string& account() const;
  void set_account(const ::std::string& value);
  #if LANG_CXX11
  void set_account(::std::string&& value);
  #endif
  void set_account(const char* value);
  void set_account(const char* value, size_t size);
  ::std::string* mutable_account();
  ::std::string* release_account();
  void set_allocated_account(::std::string* account);

  // string Password = 2;
  void clear_password();
  static const int kPasswordFieldNumber = 2;
  const ::std::string& password() const;
  void set_password(const ::std::string& value);
  #if LANG_CXX11
  void set_password(::std::string&& value);
  #endif
  void set_password(const char* value);
  void set_password(const char* value, size_t size);
  ::std::string* mutable_password();
  ::std::string* release_password();
  void set_allocated_password(::std::string* password);

  // string SecurityCode = 3;
  void clear_securitycode();
  static const int kSecurityCodeFieldNumber = 3;
  const ::std::string& securitycode() const;
  void set_securitycode(const ::std::string& value);
  #if LANG_CXX11
  void set_securitycode(::std::string&& value);
  #endif
  void set_securitycode(const char* value);
  void set_securitycode(const char* value, size_t size);
  ::std::string* mutable_securitycode();
  ::std::string* release_securitycode();
  void set_allocated_securitycode(::std::string* securitycode);

  // string MachineCode = 4;
  void clear_machinecode();
  static const int kMachineCodeFieldNumber = 4;
  const ::std::string& machinecode() const;
  void set_machinecode(const ::std::string& value);
  #if LANG_CXX11
  void set_machinecode(::std::string&& value);
  #endif
  void set_machinecode(const char* value);
  void set_machinecode(const char* value, size_t size);
  ::std::string* mutable_machinecode();
  ::std::string* release_machinecode();
  void set_allocated_machinecode(::std::string* machinecode);

  // @@protoc_insertion_point(class_scope:go.Login)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr account_;
  ::google::protobuf::internal::ArenaStringPtr password_;
  ::google::protobuf::internal::ArenaStringPtr securitycode_;
  ::google::protobuf::internal::ArenaStringPtr machinecode_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_login_2eproto;
};
// -------------------------------------------------------------------

class ResResult final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:go.ResResult) */ {
 public:
  ResResult();
  virtual ~ResResult();

  ResResult(const ResResult& from);

  inline ResResult& operator=(const ResResult& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResResult(ResResult&& from) noexcept
    : ResResult() {
    *this = ::std::move(from);
  }

  inline ResResult& operator=(ResResult&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ResResult& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResResult* internal_default_instance() {
    return reinterpret_cast<const ResResult*>(
               &_ResResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(ResResult* other);
  friend void swap(ResResult& a, ResResult& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResResult* New() const final {
    return CreateMaybeMessage<ResResult>(nullptr);
  }

  ResResult* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ResResult>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ResResult& from);
  void MergeFrom(const ResResult& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResResult* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string Hints = 2;
  void clear_hints();
  static const int kHintsFieldNumber = 2;
  const ::std::string& hints() const;
  void set_hints(const ::std::string& value);
  #if LANG_CXX11
  void set_hints(::std::string&& value);
  #endif
  void set_hints(const char* value);
  void set_hints(const char* value, size_t size);
  ::std::string* mutable_hints();
  ::std::string* release_hints();
  void set_allocated_hints(::std::string* hints);

  // uint32 State = 1;
  void clear_state();
  static const int kStateFieldNumber = 1;
  ::google::protobuf::uint32 state() const;
  void set_state(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:go.ResResult)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr hints_;
  ::google::protobuf::uint32 state_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_login_2eproto;
};
// -------------------------------------------------------------------

class TaskItem final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:go.TaskItem) */ {
 public:
  TaskItem();
  virtual ~TaskItem();

  TaskItem(const TaskItem& from);

  inline TaskItem& operator=(const TaskItem& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TaskItem(TaskItem&& from) noexcept
    : TaskItem() {
    *this = ::std::move(from);
  }

  inline TaskItem& operator=(TaskItem&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const TaskItem& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TaskItem* internal_default_instance() {
    return reinterpret_cast<const TaskItem*>(
               &_TaskItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(TaskItem* other);
  friend void swap(TaskItem& a, TaskItem& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TaskItem* New() const final {
    return CreateMaybeMessage<TaskItem>(nullptr);
  }

  TaskItem* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TaskItem>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TaskItem& from);
  void MergeFrom(const TaskItem& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TaskItem* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string Hints = 3;
  void clear_hints();
  static const int kHintsFieldNumber = 3;
  const ::std::string& hints() const;
  void set_hints(const ::std::string& value);
  #if LANG_CXX11
  void set_hints(::std::string&& value);
  #endif
  void set_hints(const char* value);
  void set_hints(const char* value, size_t size);
  ::std::string* mutable_hints();
  ::std::string* release_hints();
  void set_allocated_hints(::std::string* hints);

  // uint32 TaskID = 1;
  void clear_taskid();
  static const int kTaskIDFieldNumber = 1;
  ::google::protobuf::uint32 taskid() const;
  void set_taskid(::google::protobuf::uint32 value);

  // uint32 Twice = 2;
  void clear_twice();
  static const int kTwiceFieldNumber = 2;
  ::google::protobuf::uint32 twice() const;
  void set_twice(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:go.TaskItem)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr hints_;
  ::google::protobuf::uint32 taskid_;
  ::google::protobuf::uint32 twice_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_login_2eproto;
};
// -------------------------------------------------------------------

class TaskList final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:go.TaskList) */ {
 public:
  TaskList();
  virtual ~TaskList();

  TaskList(const TaskList& from);

  inline TaskList& operator=(const TaskList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TaskList(TaskList&& from) noexcept
    : TaskList() {
    *this = ::std::move(from);
  }

  inline TaskList& operator=(TaskList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const TaskList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TaskList* internal_default_instance() {
    return reinterpret_cast<const TaskList*>(
               &_TaskList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(TaskList* other);
  friend void swap(TaskList& a, TaskList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TaskList* New() const final {
    return CreateMaybeMessage<TaskList>(nullptr);
  }

  TaskList* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TaskList>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TaskList& from);
  void MergeFrom(const TaskList& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TaskList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .go.TaskItem Task = 1;
  int task_size() const;
  void clear_task();
  static const int kTaskFieldNumber = 1;
  ::go::TaskItem* mutable_task(int index);
  ::google::protobuf::RepeatedPtrField< ::go::TaskItem >*
      mutable_task();
  const ::go::TaskItem& task(int index) const;
  ::go::TaskItem* add_task();
  const ::google::protobuf::RepeatedPtrField< ::go::TaskItem >&
      task() const;

  // @@protoc_insertion_point(class_scope:go.TaskList)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::go::TaskItem > task_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_login_2eproto;
};
// -------------------------------------------------------------------

class GameList final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:go.GameList) */ {
 public:
  GameList();
  virtual ~GameList();

  GameList(const GameList& from);

  inline GameList& operator=(const GameList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GameList(GameList&& from) noexcept
    : GameList() {
    *this = ::std::move(from);
  }

  inline GameList& operator=(GameList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const GameList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GameList* internal_default_instance() {
    return reinterpret_cast<const GameList*>(
               &_GameList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(GameList* other);
  friend void swap(GameList& a, GameList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GameList* New() const final {
    return CreateMaybeMessage<GameList>(nullptr);
  }

  GameList* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GameList>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GameList& from);
  void MergeFrom(const GameList& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .go.GameItem Items = 1;
  int items_size() const;
  void clear_items();
  static const int kItemsFieldNumber = 1;
  ::go::GameItem* mutable_items(int index);
  ::google::protobuf::RepeatedPtrField< ::go::GameItem >*
      mutable_items();
  const ::go::GameItem& items(int index) const;
  ::go::GameItem* add_items();
  const ::google::protobuf::RepeatedPtrField< ::go::GameItem >&
      items() const;

  // @@protoc_insertion_point(class_scope:go.GameList)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::go::GameItem > items_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_login_2eproto;
};
// -------------------------------------------------------------------

class UserInfo final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:go.UserInfo) */ {
 public:
  UserInfo();
  virtual ~UserInfo();

  UserInfo(const UserInfo& from);

  inline UserInfo& operator=(const UserInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UserInfo(UserInfo&& from) noexcept
    : UserInfo() {
    *this = ::std::move(from);
  }

  inline UserInfo& operator=(UserInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const UserInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserInfo* internal_default_instance() {
    return reinterpret_cast<const UserInfo*>(
               &_UserInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(UserInfo* other);
  friend void swap(UserInfo& a, UserInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UserInfo* New() const final {
    return CreateMaybeMessage<UserInfo>(nullptr);
  }

  UserInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UserInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UserInfo& from);
  void MergeFrom(const UserInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string Name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string Accounts = 2;
  void clear_accounts();
  static const int kAccountsFieldNumber = 2;
  const ::std::string& accounts() const;
  void set_accounts(const ::std::string& value);
  #if LANG_CXX11
  void set_accounts(::std::string&& value);
  #endif
  void set_accounts(const char* value);
  void set_accounts(const char* value, size_t size);
  ::std::string* mutable_accounts();
  ::std::string* release_accounts();
  void set_allocated_accounts(::std::string* accounts);

  // string Password = 3;
  void clear_password();
  static const int kPasswordFieldNumber = 3;
  const ::std::string& password() const;
  void set_password(const ::std::string& value);
  #if LANG_CXX11
  void set_password(::std::string&& value);
  #endif
  void set_password(const char* value);
  void set_password(const char* value, size_t size);
  ::std::string* mutable_password();
  ::std::string* release_password();
  void set_allocated_password(::std::string* password);

  // string PassPortID = 9;
  void clear_passportid();
  static const int kPassPortIDFieldNumber = 9;
  const ::std::string& passportid() const;
  void set_passportid(const ::std::string& value);
  #if LANG_CXX11
  void set_passportid(::std::string&& value);
  #endif
  void set_passportid(const char* value);
  void set_passportid(const char* value, size_t size);
  ::std::string* mutable_passportid();
  ::std::string* release_passportid();
  void set_allocated_passportid(::std::string* passportid);

  // string Compellation = 10;
  void clear_compellation();
  static const int kCompellationFieldNumber = 10;
  const ::std::string& compellation() const;
  void set_compellation(const ::std::string& value);
  #if LANG_CXX11
  void set_compellation(::std::string&& value);
  #endif
  void set_compellation(const char* value);
  void set_compellation(const char* value, size_t size);
  ::std::string* mutable_compellation();
  ::std::string* release_compellation();
  void set_allocated_compellation(::std::string* compellation);

  // string MachineCode = 14;
  void clear_machinecode();
  static const int kMachineCodeFieldNumber = 14;
  const ::std::string& machinecode() const;
  void set_machinecode(const ::std::string& value);
  #if LANG_CXX11
  void set_machinecode(::std::string&& value);
  #endif
  void set_machinecode(const char* value);
  void set_machinecode(const char* value, size_t size);
  ::std::string* mutable_machinecode();
  ::std::string* release_machinecode();
  void set_allocated_machinecode(::std::string* machinecode);

  // uint32 FaceID = 4;
  void clear_faceid();
  static const int kFaceIDFieldNumber = 4;
  ::google::protobuf::uint32 faceid() const;
  void set_faceid(::google::protobuf::uint32 value);

  // uint32 Gender = 5;
  void clear_gender();
  static const int kGenderFieldNumber = 5;
  ::google::protobuf::uint32 gender() const;
  void set_gender(::google::protobuf::uint32 value);

  // uint32 Age = 6;
  void clear_age();
  static const int kAgeFieldNumber = 6;
  ::google::protobuf::uint32 age() const;
  void set_age(::google::protobuf::uint32 value);

  // uint32 Level = 7;
  void clear_level();
  static const int kLevelFieldNumber = 7;
  ::google::protobuf::uint32 level() const;
  void set_level(::google::protobuf::uint32 value);

  // int64 Money = 8;
  void clear_money();
  static const int kMoneyFieldNumber = 8;
  ::google::protobuf::int64 money() const;
  void set_money(::google::protobuf::int64 value);

  // uint32 AgentID = 11;
  void clear_agentid();
  static const int kAgentIDFieldNumber = 11;
  ::google::protobuf::uint32 agentid() const;
  void set_agentid(::google::protobuf::uint32 value);

  // uint32 SpreaderGameID = 12;
  void clear_spreadergameid();
  static const int kSpreaderGameIDFieldNumber = 12;
  ::google::protobuf::uint32 spreadergameid() const;
  void set_spreadergameid(::google::protobuf::uint32 value);

  // uint32 ClientAddr = 13;
  void clear_clientaddr();
  static const int kClientAddrFieldNumber = 13;
  ::google::protobuf::uint32 clientaddr() const;
  void set_clientaddr(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:go.UserInfo)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr accounts_;
  ::google::protobuf::internal::ArenaStringPtr password_;
  ::google::protobuf::internal::ArenaStringPtr passportid_;
  ::google::protobuf::internal::ArenaStringPtr compellation_;
  ::google::protobuf::internal::ArenaStringPtr machinecode_;
  ::google::protobuf::uint32 faceid_;
  ::google::protobuf::uint32 gender_;
  ::google::protobuf::uint32 age_;
  ::google::protobuf::uint32 level_;
  ::google::protobuf::int64 money_;
  ::google::protobuf::uint32 agentid_;
  ::google::protobuf::uint32 spreadergameid_;
  ::google::protobuf::uint32 clientaddr_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_login_2eproto;
};
// -------------------------------------------------------------------

class RoomInfo final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:go.RoomInfo) */ {
 public:
  RoomInfo();
  virtual ~RoomInfo();

  RoomInfo(const RoomInfo& from);

  inline RoomInfo& operator=(const RoomInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RoomInfo(RoomInfo&& from) noexcept
    : RoomInfo() {
    *this = ::std::move(from);
  }

  inline RoomInfo& operator=(RoomInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const RoomInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RoomInfo* internal_default_instance() {
    return reinterpret_cast<const RoomInfo*>(
               &_RoomInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(RoomInfo* other);
  friend void swap(RoomInfo& a, RoomInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RoomInfo* New() const final {
    return CreateMaybeMessage<RoomInfo>(nullptr);
  }

  RoomInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RoomInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RoomInfo& from);
  void MergeFrom(const RoomInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoomInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string RoomKey = 2;
  void clear_roomkey();
  static const int kRoomKeyFieldNumber = 2;
  const ::std::string& roomkey() const;
  void set_roomkey(const ::std::string& value);
  #if LANG_CXX11
  void set_roomkey(::std::string&& value);
  #endif
  void set_roomkey(const char* value);
  void set_roomkey(const char* value, size_t size);
  ::std::string* mutable_roomkey();
  ::std::string* release_roomkey();
  void set_allocated_roomkey(::std::string* roomkey);

  // string RoomName = 3;
  void clear_roomname();
  static const int kRoomNameFieldNumber = 3;
  const ::std::string& roomname() const;
  void set_roomname(const ::std::string& value);
  #if LANG_CXX11
  void set_roomname(::std::string&& value);
  #endif
  void set_roomname(const char* value);
  void set_roomname(const char* value, size_t size);
  ::std::string* mutable_roomname();
  ::std::string* release_roomname();
  void set_allocated_roomname(::std::string* roomname);

  // .go.GameList Games = 4;
  bool has_games() const;
  void clear_games();
  static const int kGamesFieldNumber = 4;
  const ::go::GameList& games() const;
  ::go::GameList* release_games();
  ::go::GameList* mutable_games();
  void set_allocated_games(::go::GameList* games);

  // uint32 RoomNum = 1;
  void clear_roomnum();
  static const int kRoomNumFieldNumber = 1;
  ::google::protobuf::uint32 roomnum() const;
  void set_roomnum(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:go.RoomInfo)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr roomkey_;
  ::google::protobuf::internal::ArenaStringPtr roomname_;
  ::go::GameList* games_;
  ::google::protobuf::uint32 roomnum_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_login_2eproto;
};
// -------------------------------------------------------------------

class GameBaseInfo final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:go.GameBaseInfo) */ {
 public:
  GameBaseInfo();
  virtual ~GameBaseInfo();

  GameBaseInfo(const GameBaseInfo& from);

  inline GameBaseInfo& operator=(const GameBaseInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GameBaseInfo(GameBaseInfo&& from) noexcept
    : GameBaseInfo() {
    *this = ::std::move(from);
  }

  inline GameBaseInfo& operator=(GameBaseInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const GameBaseInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GameBaseInfo* internal_default_instance() {
    return reinterpret_cast<const GameBaseInfo*>(
               &_GameBaseInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(GameBaseInfo* other);
  friend void swap(GameBaseInfo& a, GameBaseInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GameBaseInfo* New() const final {
    return CreateMaybeMessage<GameBaseInfo>(nullptr);
  }

  GameBaseInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GameBaseInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GameBaseInfo& from);
  void MergeFrom(const GameBaseInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameBaseInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string Name = 4;
  void clear_name();
  static const int kNameFieldNumber = 4;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // uint32 Type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::google::protobuf::uint32 type() const;
  void set_type(::google::protobuf::uint32 value);

  // uint32 KindID = 2;
  void clear_kindid();
  static const int kKindIDFieldNumber = 2;
  ::google::protobuf::uint32 kindid() const;
  void set_kindid(::google::protobuf::uint32 value);

  // uint32 Level = 3;
  void clear_level();
  static const int kLevelFieldNumber = 3;
  ::google::protobuf::uint32 level() const;
  void set_level(::google::protobuf::uint32 value);

  // uint32 EnterScore = 5;
  void clear_enterscore();
  static const int kEnterScoreFieldNumber = 5;
  ::google::protobuf::uint32 enterscore() const;
  void set_enterscore(::google::protobuf::uint32 value);

  // uint32 LessScore = 6;
  void clear_lessscore();
  static const int kLessScoreFieldNumber = 6;
  ::google::protobuf::uint32 lessscore() const;
  void set_lessscore(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:go.GameBaseInfo)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::uint32 type_;
  ::google::protobuf::uint32 kindid_;
  ::google::protobuf::uint32 level_;
  ::google::protobuf::uint32 enterscore_;
  ::google::protobuf::uint32 lessscore_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_login_2eproto;
};
// -------------------------------------------------------------------

class GameItem final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:go.GameItem) */ {
 public:
  GameItem();
  virtual ~GameItem();

  GameItem(const GameItem& from);

  inline GameItem& operator=(const GameItem& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GameItem(GameItem&& from) noexcept
    : GameItem() {
    *this = ::std::move(from);
  }

  inline GameItem& operator=(GameItem&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const GameItem& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GameItem* internal_default_instance() {
    return reinterpret_cast<const GameItem*>(
               &_GameItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(GameItem* other);
  friend void swap(GameItem& a, GameItem& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GameItem* New() const final {
    return CreateMaybeMessage<GameItem>(nullptr);
  }

  GameItem* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GameItem>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GameItem& from);
  void MergeFrom(const GameItem& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameItem* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .go.GameBaseInfo Info = 2;
  bool has_info() const;
  void clear_info();
  static const int kInfoFieldNumber = 2;
  const ::go::GameBaseInfo& info() const;
  ::go::GameBaseInfo* release_info();
  ::go::GameBaseInfo* mutable_info();
  void set_allocated_info(::go::GameBaseInfo* info);

  // uint32 ID = 1;
  void clear_id();
  static const int kIDFieldNumber = 1;
  ::google::protobuf::uint32 id() const;
  void set_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:go.GameItem)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::go::GameBaseInfo* info_;
  ::google::protobuf::uint32 id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_login_2eproto;
};
// -------------------------------------------------------------------

class MasterInfo final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:go.MasterInfo) */ {
 public:
  MasterInfo();
  virtual ~MasterInfo();

  MasterInfo(const MasterInfo& from);

  inline MasterInfo& operator=(const MasterInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MasterInfo(MasterInfo&& from) noexcept
    : MasterInfo() {
    *this = ::std::move(from);
  }

  inline MasterInfo& operator=(MasterInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const MasterInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MasterInfo* internal_default_instance() {
    return reinterpret_cast<const MasterInfo*>(
               &_MasterInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(MasterInfo* other);
  friend void swap(MasterInfo& a, MasterInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MasterInfo* New() const final {
    return CreateMaybeMessage<MasterInfo>(nullptr);
  }

  MasterInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MasterInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MasterInfo& from);
  void MergeFrom(const MasterInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MasterInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .go.RoomInfo RoomsInfo = 2;
  int roomsinfo_size() const;
  void clear_roomsinfo();
  static const int kRoomsInfoFieldNumber = 2;
  ::go::RoomInfo* mutable_roomsinfo(int index);
  ::google::protobuf::RepeatedPtrField< ::go::RoomInfo >*
      mutable_roomsinfo();
  const ::go::RoomInfo& roomsinfo(int index) const;
  ::go::RoomInfo* add_roomsinfo();
  const ::google::protobuf::RepeatedPtrField< ::go::RoomInfo >&
      roomsinfo() const;

  // .go.UserInfo UserInfo = 1;
  bool has_userinfo() const;
  void clear_userinfo();
  static const int kUserInfoFieldNumber = 1;
  const ::go::UserInfo& userinfo() const;
  ::go::UserInfo* release_userinfo();
  ::go::UserInfo* mutable_userinfo();
  void set_allocated_userinfo(::go::UserInfo* userinfo);

  // .go.TaskList Tasks = 3;
  bool has_tasks() const;
  void clear_tasks();
  static const int kTasksFieldNumber = 3;
  const ::go::TaskList& tasks() const;
  ::go::TaskList* release_tasks();
  ::go::TaskList* mutable_tasks();
  void set_allocated_tasks(::go::TaskList* tasks);

  // @@protoc_insertion_point(class_scope:go.MasterInfo)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::go::RoomInfo > roomsinfo_;
  ::go::UserInfo* userinfo_;
  ::go::TaskList* tasks_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_login_2eproto;
};
// -------------------------------------------------------------------

class ReqEnterRoom final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:go.ReqEnterRoom) */ {
 public:
  ReqEnterRoom();
  virtual ~ReqEnterRoom();

  ReqEnterRoom(const ReqEnterRoom& from);

  inline ReqEnterRoom& operator=(const ReqEnterRoom& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReqEnterRoom(ReqEnterRoom&& from) noexcept
    : ReqEnterRoom() {
    *this = ::std::move(from);
  }

  inline ReqEnterRoom& operator=(ReqEnterRoom&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ReqEnterRoom& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReqEnterRoom* internal_default_instance() {
    return reinterpret_cast<const ReqEnterRoom*>(
               &_ReqEnterRoom_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(ReqEnterRoom* other);
  friend void swap(ReqEnterRoom& a, ReqEnterRoom& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReqEnterRoom* New() const final {
    return CreateMaybeMessage<ReqEnterRoom>(nullptr);
  }

  ReqEnterRoom* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ReqEnterRoom>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ReqEnterRoom& from);
  void MergeFrom(const ReqEnterRoom& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReqEnterRoom* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string RoomKey = 2;
  void clear_roomkey();
  static const int kRoomKeyFieldNumber = 2;
  const ::std::string& roomkey() const;
  void set_roomkey(const ::std::string& value);
  #if LANG_CXX11
  void set_roomkey(::std::string&& value);
  #endif
  void set_roomkey(const char* value);
  void set_roomkey(const char* value, size_t size);
  ::std::string* mutable_roomkey();
  ::std::string* release_roomkey();
  void set_allocated_roomkey(::std::string* roomkey);

  // uint32 RoomNum = 1;
  void clear_roomnum();
  static const int kRoomNumFieldNumber = 1;
  ::google::protobuf::uint32 roomnum() const;
  void set_roomnum(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:go.ReqEnterRoom)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr roomkey_;
  ::google::protobuf::uint32 roomnum_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_login_2eproto;
};
// -------------------------------------------------------------------

class ReqEnterGame final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:go.ReqEnterGame) */ {
 public:
  ReqEnterGame();
  virtual ~ReqEnterGame();

  ReqEnterGame(const ReqEnterGame& from);

  inline ReqEnterGame& operator=(const ReqEnterGame& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReqEnterGame(ReqEnterGame&& from) noexcept
    : ReqEnterGame() {
    *this = ::std::move(from);
  }

  inline ReqEnterGame& operator=(ReqEnterGame&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ReqEnterGame& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReqEnterGame* internal_default_instance() {
    return reinterpret_cast<const ReqEnterGame*>(
               &_ReqEnterGame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(ReqEnterGame* other);
  friend void swap(ReqEnterGame& a, ReqEnterGame& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReqEnterGame* New() const final {
    return CreateMaybeMessage<ReqEnterGame>(nullptr);
  }

  ReqEnterGame* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ReqEnterGame>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ReqEnterGame& from);
  void MergeFrom(const ReqEnterGame& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReqEnterGame* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 GameID = 1;
  void clear_gameid();
  static const int kGameIDFieldNumber = 1;
  ::google::protobuf::uint32 gameid() const;
  void set_gameid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:go.ReqEnterGame)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 gameid_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_login_2eproto;
};
// -------------------------------------------------------------------

class ReqExitGame final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:go.ReqExitGame) */ {
 public:
  ReqExitGame();
  virtual ~ReqExitGame();

  ReqExitGame(const ReqExitGame& from);

  inline ReqExitGame& operator=(const ReqExitGame& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReqExitGame(ReqExitGame&& from) noexcept
    : ReqExitGame() {
    *this = ::std::move(from);
  }

  inline ReqExitGame& operator=(ReqExitGame&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ReqExitGame& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReqExitGame* internal_default_instance() {
    return reinterpret_cast<const ReqExitGame*>(
               &_ReqExitGame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(ReqExitGame* other);
  friend void swap(ReqExitGame& a, ReqExitGame& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReqExitGame* New() const final {
    return CreateMaybeMessage<ReqExitGame>(nullptr);
  }

  ReqExitGame* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ReqExitGame>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ReqExitGame& from);
  void MergeFrom(const ReqExitGame& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReqExitGame* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 GameID = 1;
  void clear_gameid();
  static const int kGameIDFieldNumber = 1;
  ::google::protobuf::uint32 gameid() const;
  void set_gameid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:go.ReqExitGame)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 gameid_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_login_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Register

// string Name = 1;
inline void Register::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Register::name() const {
  // @@protoc_insertion_point(field_get:go.Register.Name)
  return name_.GetNoArena();
}
inline void Register::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:go.Register.Name)
}
#if LANG_CXX11
inline void Register::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:go.Register.Name)
}
#endif
inline void Register::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:go.Register.Name)
}
inline void Register::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:go.Register.Name)
}
inline ::std::string* Register::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:go.Register.Name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Register::release_name() {
  // @@protoc_insertion_point(field_release:go.Register.Name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Register::set_allocated_name(::std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:go.Register.Name)
}

// string Password = 2;
inline void Register::clear_password() {
  password_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Register::password() const {
  // @@protoc_insertion_point(field_get:go.Register.Password)
  return password_.GetNoArena();
}
inline void Register::set_password(const ::std::string& value) {
  
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:go.Register.Password)
}
#if LANG_CXX11
inline void Register::set_password(::std::string&& value) {
  
  password_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:go.Register.Password)
}
#endif
inline void Register::set_password(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:go.Register.Password)
}
inline void Register::set_password(const char* value, size_t size) {
  
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:go.Register.Password)
}
inline ::std::string* Register::mutable_password() {
  
  // @@protoc_insertion_point(field_mutable:go.Register.Password)
  return password_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Register::release_password() {
  // @@protoc_insertion_point(field_release:go.Register.Password)
  
  return password_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Register::set_allocated_password(::std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  password_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), password);
  // @@protoc_insertion_point(field_set_allocated:go.Register.Password)
}

// string SecurityCode = 3;
inline void Register::clear_securitycode() {
  securitycode_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Register::securitycode() const {
  // @@protoc_insertion_point(field_get:go.Register.SecurityCode)
  return securitycode_.GetNoArena();
}
inline void Register::set_securitycode(const ::std::string& value) {
  
  securitycode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:go.Register.SecurityCode)
}
#if LANG_CXX11
inline void Register::set_securitycode(::std::string&& value) {
  
  securitycode_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:go.Register.SecurityCode)
}
#endif
inline void Register::set_securitycode(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  securitycode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:go.Register.SecurityCode)
}
inline void Register::set_securitycode(const char* value, size_t size) {
  
  securitycode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:go.Register.SecurityCode)
}
inline ::std::string* Register::mutable_securitycode() {
  
  // @@protoc_insertion_point(field_mutable:go.Register.SecurityCode)
  return securitycode_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Register::release_securitycode() {
  // @@protoc_insertion_point(field_release:go.Register.SecurityCode)
  
  return securitycode_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Register::set_allocated_securitycode(::std::string* securitycode) {
  if (securitycode != nullptr) {
    
  } else {
    
  }
  securitycode_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), securitycode);
  // @@protoc_insertion_point(field_set_allocated:go.Register.SecurityCode)
}

// string MachineCode = 4;
inline void Register::clear_machinecode() {
  machinecode_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Register::machinecode() const {
  // @@protoc_insertion_point(field_get:go.Register.MachineCode)
  return machinecode_.GetNoArena();
}
inline void Register::set_machinecode(const ::std::string& value) {
  
  machinecode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:go.Register.MachineCode)
}
#if LANG_CXX11
inline void Register::set_machinecode(::std::string&& value) {
  
  machinecode_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:go.Register.MachineCode)
}
#endif
inline void Register::set_machinecode(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  machinecode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:go.Register.MachineCode)
}
inline void Register::set_machinecode(const char* value, size_t size) {
  
  machinecode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:go.Register.MachineCode)
}
inline ::std::string* Register::mutable_machinecode() {
  
  // @@protoc_insertion_point(field_mutable:go.Register.MachineCode)
  return machinecode_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Register::release_machinecode() {
  // @@protoc_insertion_point(field_release:go.Register.MachineCode)
  
  return machinecode_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Register::set_allocated_machinecode(::std::string* machinecode) {
  if (machinecode != nullptr) {
    
  } else {
    
  }
  machinecode_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), machinecode);
  // @@protoc_insertion_point(field_set_allocated:go.Register.MachineCode)
}

// string InvitationCode = 5;
inline void Register::clear_invitationcode() {
  invitationcode_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Register::invitationcode() const {
  // @@protoc_insertion_point(field_get:go.Register.InvitationCode)
  return invitationcode_.GetNoArena();
}
inline void Register::set_invitationcode(const ::std::string& value) {
  
  invitationcode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:go.Register.InvitationCode)
}
#if LANG_CXX11
inline void Register::set_invitationcode(::std::string&& value) {
  
  invitationcode_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:go.Register.InvitationCode)
}
#endif
inline void Register::set_invitationcode(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  invitationcode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:go.Register.InvitationCode)
}
inline void Register::set_invitationcode(const char* value, size_t size) {
  
  invitationcode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:go.Register.InvitationCode)
}
inline ::std::string* Register::mutable_invitationcode() {
  
  // @@protoc_insertion_point(field_mutable:go.Register.InvitationCode)
  return invitationcode_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Register::release_invitationcode() {
  // @@protoc_insertion_point(field_release:go.Register.InvitationCode)
  
  return invitationcode_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Register::set_allocated_invitationcode(::std::string* invitationcode) {
  if (invitationcode != nullptr) {
    
  } else {
    
  }
  invitationcode_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), invitationcode);
  // @@protoc_insertion_point(field_set_allocated:go.Register.InvitationCode)
}

// -------------------------------------------------------------------

// RegisterResult

// uint32 State = 1;
inline void RegisterResult::clear_state() {
  state_ = 0u;
}
inline ::google::protobuf::uint32 RegisterResult::state() const {
  // @@protoc_insertion_point(field_get:go.RegisterResult.State)
  return state_;
}
inline void RegisterResult::set_state(::google::protobuf::uint32 value) {
  
  state_ = value;
  // @@protoc_insertion_point(field_set:go.RegisterResult.State)
}

// string Hints = 2;
inline void RegisterResult::clear_hints() {
  hints_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RegisterResult::hints() const {
  // @@protoc_insertion_point(field_get:go.RegisterResult.Hints)
  return hints_.GetNoArena();
}
inline void RegisterResult::set_hints(const ::std::string& value) {
  
  hints_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:go.RegisterResult.Hints)
}
#if LANG_CXX11
inline void RegisterResult::set_hints(::std::string&& value) {
  
  hints_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:go.RegisterResult.Hints)
}
#endif
inline void RegisterResult::set_hints(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  hints_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:go.RegisterResult.Hints)
}
inline void RegisterResult::set_hints(const char* value, size_t size) {
  
  hints_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:go.RegisterResult.Hints)
}
inline ::std::string* RegisterResult::mutable_hints() {
  
  // @@protoc_insertion_point(field_mutable:go.RegisterResult.Hints)
  return hints_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RegisterResult::release_hints() {
  // @@protoc_insertion_point(field_release:go.RegisterResult.Hints)
  
  return hints_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RegisterResult::set_allocated_hints(::std::string* hints) {
  if (hints != nullptr) {
    
  } else {
    
  }
  hints_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hints);
  // @@protoc_insertion_point(field_set_allocated:go.RegisterResult.Hints)
}

// -------------------------------------------------------------------

// Login

// string Account = 1;
inline void Login::clear_account() {
  account_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Login::account() const {
  // @@protoc_insertion_point(field_get:go.Login.Account)
  return account_.GetNoArena();
}
inline void Login::set_account(const ::std::string& value) {
  
  account_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:go.Login.Account)
}
#if LANG_CXX11
inline void Login::set_account(::std::string&& value) {
  
  account_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:go.Login.Account)
}
#endif
inline void Login::set_account(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  account_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:go.Login.Account)
}
inline void Login::set_account(const char* value, size_t size) {
  
  account_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:go.Login.Account)
}
inline ::std::string* Login::mutable_account() {
  
  // @@protoc_insertion_point(field_mutable:go.Login.Account)
  return account_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Login::release_account() {
  // @@protoc_insertion_point(field_release:go.Login.Account)
  
  return account_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Login::set_allocated_account(::std::string* account) {
  if (account != nullptr) {
    
  } else {
    
  }
  account_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), account);
  // @@protoc_insertion_point(field_set_allocated:go.Login.Account)
}

// string Password = 2;
inline void Login::clear_password() {
  password_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Login::password() const {
  // @@protoc_insertion_point(field_get:go.Login.Password)
  return password_.GetNoArena();
}
inline void Login::set_password(const ::std::string& value) {
  
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:go.Login.Password)
}
#if LANG_CXX11
inline void Login::set_password(::std::string&& value) {
  
  password_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:go.Login.Password)
}
#endif
inline void Login::set_password(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:go.Login.Password)
}
inline void Login::set_password(const char* value, size_t size) {
  
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:go.Login.Password)
}
inline ::std::string* Login::mutable_password() {
  
  // @@protoc_insertion_point(field_mutable:go.Login.Password)
  return password_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Login::release_password() {
  // @@protoc_insertion_point(field_release:go.Login.Password)
  
  return password_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Login::set_allocated_password(::std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  password_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), password);
  // @@protoc_insertion_point(field_set_allocated:go.Login.Password)
}

// string SecurityCode = 3;
inline void Login::clear_securitycode() {
  securitycode_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Login::securitycode() const {
  // @@protoc_insertion_point(field_get:go.Login.SecurityCode)
  return securitycode_.GetNoArena();
}
inline void Login::set_securitycode(const ::std::string& value) {
  
  securitycode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:go.Login.SecurityCode)
}
#if LANG_CXX11
inline void Login::set_securitycode(::std::string&& value) {
  
  securitycode_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:go.Login.SecurityCode)
}
#endif
inline void Login::set_securitycode(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  securitycode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:go.Login.SecurityCode)
}
inline void Login::set_securitycode(const char* value, size_t size) {
  
  securitycode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:go.Login.SecurityCode)
}
inline ::std::string* Login::mutable_securitycode() {
  
  // @@protoc_insertion_point(field_mutable:go.Login.SecurityCode)
  return securitycode_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Login::release_securitycode() {
  // @@protoc_insertion_point(field_release:go.Login.SecurityCode)
  
  return securitycode_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Login::set_allocated_securitycode(::std::string* securitycode) {
  if (securitycode != nullptr) {
    
  } else {
    
  }
  securitycode_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), securitycode);
  // @@protoc_insertion_point(field_set_allocated:go.Login.SecurityCode)
}

// string MachineCode = 4;
inline void Login::clear_machinecode() {
  machinecode_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Login::machinecode() const {
  // @@protoc_insertion_point(field_get:go.Login.MachineCode)
  return machinecode_.GetNoArena();
}
inline void Login::set_machinecode(const ::std::string& value) {
  
  machinecode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:go.Login.MachineCode)
}
#if LANG_CXX11
inline void Login::set_machinecode(::std::string&& value) {
  
  machinecode_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:go.Login.MachineCode)
}
#endif
inline void Login::set_machinecode(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  machinecode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:go.Login.MachineCode)
}
inline void Login::set_machinecode(const char* value, size_t size) {
  
  machinecode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:go.Login.MachineCode)
}
inline ::std::string* Login::mutable_machinecode() {
  
  // @@protoc_insertion_point(field_mutable:go.Login.MachineCode)
  return machinecode_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Login::release_machinecode() {
  // @@protoc_insertion_point(field_release:go.Login.MachineCode)
  
  return machinecode_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Login::set_allocated_machinecode(::std::string* machinecode) {
  if (machinecode != nullptr) {
    
  } else {
    
  }
  machinecode_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), machinecode);
  // @@protoc_insertion_point(field_set_allocated:go.Login.MachineCode)
}

// -------------------------------------------------------------------

// ResResult

// uint32 State = 1;
inline void ResResult::clear_state() {
  state_ = 0u;
}
inline ::google::protobuf::uint32 ResResult::state() const {
  // @@protoc_insertion_point(field_get:go.ResResult.State)
  return state_;
}
inline void ResResult::set_state(::google::protobuf::uint32 value) {
  
  state_ = value;
  // @@protoc_insertion_point(field_set:go.ResResult.State)
}

// string Hints = 2;
inline void ResResult::clear_hints() {
  hints_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ResResult::hints() const {
  // @@protoc_insertion_point(field_get:go.ResResult.Hints)
  return hints_.GetNoArena();
}
inline void ResResult::set_hints(const ::std::string& value) {
  
  hints_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:go.ResResult.Hints)
}
#if LANG_CXX11
inline void ResResult::set_hints(::std::string&& value) {
  
  hints_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:go.ResResult.Hints)
}
#endif
inline void ResResult::set_hints(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  hints_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:go.ResResult.Hints)
}
inline void ResResult::set_hints(const char* value, size_t size) {
  
  hints_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:go.ResResult.Hints)
}
inline ::std::string* ResResult::mutable_hints() {
  
  // @@protoc_insertion_point(field_mutable:go.ResResult.Hints)
  return hints_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResResult::release_hints() {
  // @@protoc_insertion_point(field_release:go.ResResult.Hints)
  
  return hints_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResResult::set_allocated_hints(::std::string* hints) {
  if (hints != nullptr) {
    
  } else {
    
  }
  hints_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hints);
  // @@protoc_insertion_point(field_set_allocated:go.ResResult.Hints)
}

// -------------------------------------------------------------------

// TaskItem

// uint32 TaskID = 1;
inline void TaskItem::clear_taskid() {
  taskid_ = 0u;
}
inline ::google::protobuf::uint32 TaskItem::taskid() const {
  // @@protoc_insertion_point(field_get:go.TaskItem.TaskID)
  return taskid_;
}
inline void TaskItem::set_taskid(::google::protobuf::uint32 value) {
  
  taskid_ = value;
  // @@protoc_insertion_point(field_set:go.TaskItem.TaskID)
}

// uint32 Twice = 2;
inline void TaskItem::clear_twice() {
  twice_ = 0u;
}
inline ::google::protobuf::uint32 TaskItem::twice() const {
  // @@protoc_insertion_point(field_get:go.TaskItem.Twice)
  return twice_;
}
inline void TaskItem::set_twice(::google::protobuf::uint32 value) {
  
  twice_ = value;
  // @@protoc_insertion_point(field_set:go.TaskItem.Twice)
}

// string Hints = 3;
inline void TaskItem::clear_hints() {
  hints_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TaskItem::hints() const {
  // @@protoc_insertion_point(field_get:go.TaskItem.Hints)
  return hints_.GetNoArena();
}
inline void TaskItem::set_hints(const ::std::string& value) {
  
  hints_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:go.TaskItem.Hints)
}
#if LANG_CXX11
inline void TaskItem::set_hints(::std::string&& value) {
  
  hints_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:go.TaskItem.Hints)
}
#endif
inline void TaskItem::set_hints(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  hints_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:go.TaskItem.Hints)
}
inline void TaskItem::set_hints(const char* value, size_t size) {
  
  hints_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:go.TaskItem.Hints)
}
inline ::std::string* TaskItem::mutable_hints() {
  
  // @@protoc_insertion_point(field_mutable:go.TaskItem.Hints)
  return hints_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TaskItem::release_hints() {
  // @@protoc_insertion_point(field_release:go.TaskItem.Hints)
  
  return hints_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TaskItem::set_allocated_hints(::std::string* hints) {
  if (hints != nullptr) {
    
  } else {
    
  }
  hints_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hints);
  // @@protoc_insertion_point(field_set_allocated:go.TaskItem.Hints)
}

// -------------------------------------------------------------------

// TaskList

// repeated .go.TaskItem Task = 1;
inline int TaskList::task_size() const {
  return task_.size();
}
inline void TaskList::clear_task() {
  task_.Clear();
}
inline ::go::TaskItem* TaskList::mutable_task(int index) {
  // @@protoc_insertion_point(field_mutable:go.TaskList.Task)
  return task_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::go::TaskItem >*
TaskList::mutable_task() {
  // @@protoc_insertion_point(field_mutable_list:go.TaskList.Task)
  return &task_;
}
inline const ::go::TaskItem& TaskList::task(int index) const {
  // @@protoc_insertion_point(field_get:go.TaskList.Task)
  return task_.Get(index);
}
inline ::go::TaskItem* TaskList::add_task() {
  // @@protoc_insertion_point(field_add:go.TaskList.Task)
  return task_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::go::TaskItem >&
TaskList::task() const {
  // @@protoc_insertion_point(field_list:go.TaskList.Task)
  return task_;
}

// -------------------------------------------------------------------

// GameList

// repeated .go.GameItem Items = 1;
inline int GameList::items_size() const {
  return items_.size();
}
inline void GameList::clear_items() {
  items_.Clear();
}
inline ::go::GameItem* GameList::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:go.GameList.Items)
  return items_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::go::GameItem >*
GameList::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:go.GameList.Items)
  return &items_;
}
inline const ::go::GameItem& GameList::items(int index) const {
  // @@protoc_insertion_point(field_get:go.GameList.Items)
  return items_.Get(index);
}
inline ::go::GameItem* GameList::add_items() {
  // @@protoc_insertion_point(field_add:go.GameList.Items)
  return items_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::go::GameItem >&
GameList::items() const {
  // @@protoc_insertion_point(field_list:go.GameList.Items)
  return items_;
}

// -------------------------------------------------------------------

// UserInfo

// string Name = 1;
inline void UserInfo::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& UserInfo::name() const {
  // @@protoc_insertion_point(field_get:go.UserInfo.Name)
  return name_.GetNoArena();
}
inline void UserInfo::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:go.UserInfo.Name)
}
#if LANG_CXX11
inline void UserInfo::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:go.UserInfo.Name)
}
#endif
inline void UserInfo::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:go.UserInfo.Name)
}
inline void UserInfo::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:go.UserInfo.Name)
}
inline ::std::string* UserInfo::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:go.UserInfo.Name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UserInfo::release_name() {
  // @@protoc_insertion_point(field_release:go.UserInfo.Name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UserInfo::set_allocated_name(::std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:go.UserInfo.Name)
}

// string Accounts = 2;
inline void UserInfo::clear_accounts() {
  accounts_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& UserInfo::accounts() const {
  // @@protoc_insertion_point(field_get:go.UserInfo.Accounts)
  return accounts_.GetNoArena();
}
inline void UserInfo::set_accounts(const ::std::string& value) {
  
  accounts_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:go.UserInfo.Accounts)
}
#if LANG_CXX11
inline void UserInfo::set_accounts(::std::string&& value) {
  
  accounts_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:go.UserInfo.Accounts)
}
#endif
inline void UserInfo::set_accounts(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  accounts_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:go.UserInfo.Accounts)
}
inline void UserInfo::set_accounts(const char* value, size_t size) {
  
  accounts_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:go.UserInfo.Accounts)
}
inline ::std::string* UserInfo::mutable_accounts() {
  
  // @@protoc_insertion_point(field_mutable:go.UserInfo.Accounts)
  return accounts_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UserInfo::release_accounts() {
  // @@protoc_insertion_point(field_release:go.UserInfo.Accounts)
  
  return accounts_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UserInfo::set_allocated_accounts(::std::string* accounts) {
  if (accounts != nullptr) {
    
  } else {
    
  }
  accounts_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), accounts);
  // @@protoc_insertion_point(field_set_allocated:go.UserInfo.Accounts)
}

// string Password = 3;
inline void UserInfo::clear_password() {
  password_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& UserInfo::password() const {
  // @@protoc_insertion_point(field_get:go.UserInfo.Password)
  return password_.GetNoArena();
}
inline void UserInfo::set_password(const ::std::string& value) {
  
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:go.UserInfo.Password)
}
#if LANG_CXX11
inline void UserInfo::set_password(::std::string&& value) {
  
  password_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:go.UserInfo.Password)
}
#endif
inline void UserInfo::set_password(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:go.UserInfo.Password)
}
inline void UserInfo::set_password(const char* value, size_t size) {
  
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:go.UserInfo.Password)
}
inline ::std::string* UserInfo::mutable_password() {
  
  // @@protoc_insertion_point(field_mutable:go.UserInfo.Password)
  return password_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UserInfo::release_password() {
  // @@protoc_insertion_point(field_release:go.UserInfo.Password)
  
  return password_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UserInfo::set_allocated_password(::std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  password_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), password);
  // @@protoc_insertion_point(field_set_allocated:go.UserInfo.Password)
}

// uint32 FaceID = 4;
inline void UserInfo::clear_faceid() {
  faceid_ = 0u;
}
inline ::google::protobuf::uint32 UserInfo::faceid() const {
  // @@protoc_insertion_point(field_get:go.UserInfo.FaceID)
  return faceid_;
}
inline void UserInfo::set_faceid(::google::protobuf::uint32 value) {
  
  faceid_ = value;
  // @@protoc_insertion_point(field_set:go.UserInfo.FaceID)
}

// uint32 Gender = 5;
inline void UserInfo::clear_gender() {
  gender_ = 0u;
}
inline ::google::protobuf::uint32 UserInfo::gender() const {
  // @@protoc_insertion_point(field_get:go.UserInfo.Gender)
  return gender_;
}
inline void UserInfo::set_gender(::google::protobuf::uint32 value) {
  
  gender_ = value;
  // @@protoc_insertion_point(field_set:go.UserInfo.Gender)
}

// uint32 Age = 6;
inline void UserInfo::clear_age() {
  age_ = 0u;
}
inline ::google::protobuf::uint32 UserInfo::age() const {
  // @@protoc_insertion_point(field_get:go.UserInfo.Age)
  return age_;
}
inline void UserInfo::set_age(::google::protobuf::uint32 value) {
  
  age_ = value;
  // @@protoc_insertion_point(field_set:go.UserInfo.Age)
}

// uint32 Level = 7;
inline void UserInfo::clear_level() {
  level_ = 0u;
}
inline ::google::protobuf::uint32 UserInfo::level() const {
  // @@protoc_insertion_point(field_get:go.UserInfo.Level)
  return level_;
}
inline void UserInfo::set_level(::google::protobuf::uint32 value) {
  
  level_ = value;
  // @@protoc_insertion_point(field_set:go.UserInfo.Level)
}

// int64 Money = 8;
inline void UserInfo::clear_money() {
  money_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 UserInfo::money() const {
  // @@protoc_insertion_point(field_get:go.UserInfo.Money)
  return money_;
}
inline void UserInfo::set_money(::google::protobuf::int64 value) {
  
  money_ = value;
  // @@protoc_insertion_point(field_set:go.UserInfo.Money)
}

// string PassPortID = 9;
inline void UserInfo::clear_passportid() {
  passportid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& UserInfo::passportid() const {
  // @@protoc_insertion_point(field_get:go.UserInfo.PassPortID)
  return passportid_.GetNoArena();
}
inline void UserInfo::set_passportid(const ::std::string& value) {
  
  passportid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:go.UserInfo.PassPortID)
}
#if LANG_CXX11
inline void UserInfo::set_passportid(::std::string&& value) {
  
  passportid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:go.UserInfo.PassPortID)
}
#endif
inline void UserInfo::set_passportid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  passportid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:go.UserInfo.PassPortID)
}
inline void UserInfo::set_passportid(const char* value, size_t size) {
  
  passportid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:go.UserInfo.PassPortID)
}
inline ::std::string* UserInfo::mutable_passportid() {
  
  // @@protoc_insertion_point(field_mutable:go.UserInfo.PassPortID)
  return passportid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UserInfo::release_passportid() {
  // @@protoc_insertion_point(field_release:go.UserInfo.PassPortID)
  
  return passportid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UserInfo::set_allocated_passportid(::std::string* passportid) {
  if (passportid != nullptr) {
    
  } else {
    
  }
  passportid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), passportid);
  // @@protoc_insertion_point(field_set_allocated:go.UserInfo.PassPortID)
}

// string Compellation = 10;
inline void UserInfo::clear_compellation() {
  compellation_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& UserInfo::compellation() const {
  // @@protoc_insertion_point(field_get:go.UserInfo.Compellation)
  return compellation_.GetNoArena();
}
inline void UserInfo::set_compellation(const ::std::string& value) {
  
  compellation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:go.UserInfo.Compellation)
}
#if LANG_CXX11
inline void UserInfo::set_compellation(::std::string&& value) {
  
  compellation_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:go.UserInfo.Compellation)
}
#endif
inline void UserInfo::set_compellation(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  compellation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:go.UserInfo.Compellation)
}
inline void UserInfo::set_compellation(const char* value, size_t size) {
  
  compellation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:go.UserInfo.Compellation)
}
inline ::std::string* UserInfo::mutable_compellation() {
  
  // @@protoc_insertion_point(field_mutable:go.UserInfo.Compellation)
  return compellation_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UserInfo::release_compellation() {
  // @@protoc_insertion_point(field_release:go.UserInfo.Compellation)
  
  return compellation_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UserInfo::set_allocated_compellation(::std::string* compellation) {
  if (compellation != nullptr) {
    
  } else {
    
  }
  compellation_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), compellation);
  // @@protoc_insertion_point(field_set_allocated:go.UserInfo.Compellation)
}

// uint32 AgentID = 11;
inline void UserInfo::clear_agentid() {
  agentid_ = 0u;
}
inline ::google::protobuf::uint32 UserInfo::agentid() const {
  // @@protoc_insertion_point(field_get:go.UserInfo.AgentID)
  return agentid_;
}
inline void UserInfo::set_agentid(::google::protobuf::uint32 value) {
  
  agentid_ = value;
  // @@protoc_insertion_point(field_set:go.UserInfo.AgentID)
}

// uint32 SpreaderGameID = 12;
inline void UserInfo::clear_spreadergameid() {
  spreadergameid_ = 0u;
}
inline ::google::protobuf::uint32 UserInfo::spreadergameid() const {
  // @@protoc_insertion_point(field_get:go.UserInfo.SpreaderGameID)
  return spreadergameid_;
}
inline void UserInfo::set_spreadergameid(::google::protobuf::uint32 value) {
  
  spreadergameid_ = value;
  // @@protoc_insertion_point(field_set:go.UserInfo.SpreaderGameID)
}

// uint32 ClientAddr = 13;
inline void UserInfo::clear_clientaddr() {
  clientaddr_ = 0u;
}
inline ::google::protobuf::uint32 UserInfo::clientaddr() const {
  // @@protoc_insertion_point(field_get:go.UserInfo.ClientAddr)
  return clientaddr_;
}
inline void UserInfo::set_clientaddr(::google::protobuf::uint32 value) {
  
  clientaddr_ = value;
  // @@protoc_insertion_point(field_set:go.UserInfo.ClientAddr)
}

// string MachineCode = 14;
inline void UserInfo::clear_machinecode() {
  machinecode_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& UserInfo::machinecode() const {
  // @@protoc_insertion_point(field_get:go.UserInfo.MachineCode)
  return machinecode_.GetNoArena();
}
inline void UserInfo::set_machinecode(const ::std::string& value) {
  
  machinecode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:go.UserInfo.MachineCode)
}
#if LANG_CXX11
inline void UserInfo::set_machinecode(::std::string&& value) {
  
  machinecode_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:go.UserInfo.MachineCode)
}
#endif
inline void UserInfo::set_machinecode(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  machinecode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:go.UserInfo.MachineCode)
}
inline void UserInfo::set_machinecode(const char* value, size_t size) {
  
  machinecode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:go.UserInfo.MachineCode)
}
inline ::std::string* UserInfo::mutable_machinecode() {
  
  // @@protoc_insertion_point(field_mutable:go.UserInfo.MachineCode)
  return machinecode_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UserInfo::release_machinecode() {
  // @@protoc_insertion_point(field_release:go.UserInfo.MachineCode)
  
  return machinecode_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UserInfo::set_allocated_machinecode(::std::string* machinecode) {
  if (machinecode != nullptr) {
    
  } else {
    
  }
  machinecode_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), machinecode);
  // @@protoc_insertion_point(field_set_allocated:go.UserInfo.MachineCode)
}

// -------------------------------------------------------------------

// RoomInfo

// uint32 RoomNum = 1;
inline void RoomInfo::clear_roomnum() {
  roomnum_ = 0u;
}
inline ::google::protobuf::uint32 RoomInfo::roomnum() const {
  // @@protoc_insertion_point(field_get:go.RoomInfo.RoomNum)
  return roomnum_;
}
inline void RoomInfo::set_roomnum(::google::protobuf::uint32 value) {
  
  roomnum_ = value;
  // @@protoc_insertion_point(field_set:go.RoomInfo.RoomNum)
}

// string RoomKey = 2;
inline void RoomInfo::clear_roomkey() {
  roomkey_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RoomInfo::roomkey() const {
  // @@protoc_insertion_point(field_get:go.RoomInfo.RoomKey)
  return roomkey_.GetNoArena();
}
inline void RoomInfo::set_roomkey(const ::std::string& value) {
  
  roomkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:go.RoomInfo.RoomKey)
}
#if LANG_CXX11
inline void RoomInfo::set_roomkey(::std::string&& value) {
  
  roomkey_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:go.RoomInfo.RoomKey)
}
#endif
inline void RoomInfo::set_roomkey(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  roomkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:go.RoomInfo.RoomKey)
}
inline void RoomInfo::set_roomkey(const char* value, size_t size) {
  
  roomkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:go.RoomInfo.RoomKey)
}
inline ::std::string* RoomInfo::mutable_roomkey() {
  
  // @@protoc_insertion_point(field_mutable:go.RoomInfo.RoomKey)
  return roomkey_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RoomInfo::release_roomkey() {
  // @@protoc_insertion_point(field_release:go.RoomInfo.RoomKey)
  
  return roomkey_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RoomInfo::set_allocated_roomkey(::std::string* roomkey) {
  if (roomkey != nullptr) {
    
  } else {
    
  }
  roomkey_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), roomkey);
  // @@protoc_insertion_point(field_set_allocated:go.RoomInfo.RoomKey)
}

// string RoomName = 3;
inline void RoomInfo::clear_roomname() {
  roomname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RoomInfo::roomname() const {
  // @@protoc_insertion_point(field_get:go.RoomInfo.RoomName)
  return roomname_.GetNoArena();
}
inline void RoomInfo::set_roomname(const ::std::string& value) {
  
  roomname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:go.RoomInfo.RoomName)
}
#if LANG_CXX11
inline void RoomInfo::set_roomname(::std::string&& value) {
  
  roomname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:go.RoomInfo.RoomName)
}
#endif
inline void RoomInfo::set_roomname(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  roomname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:go.RoomInfo.RoomName)
}
inline void RoomInfo::set_roomname(const char* value, size_t size) {
  
  roomname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:go.RoomInfo.RoomName)
}
inline ::std::string* RoomInfo::mutable_roomname() {
  
  // @@protoc_insertion_point(field_mutable:go.RoomInfo.RoomName)
  return roomname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RoomInfo::release_roomname() {
  // @@protoc_insertion_point(field_release:go.RoomInfo.RoomName)
  
  return roomname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RoomInfo::set_allocated_roomname(::std::string* roomname) {
  if (roomname != nullptr) {
    
  } else {
    
  }
  roomname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), roomname);
  // @@protoc_insertion_point(field_set_allocated:go.RoomInfo.RoomName)
}

// .go.GameList Games = 4;
inline bool RoomInfo::has_games() const {
  return this != internal_default_instance() && games_ != nullptr;
}
inline void RoomInfo::clear_games() {
  if (GetArenaNoVirtual() == nullptr && games_ != nullptr) {
    delete games_;
  }
  games_ = nullptr;
}
inline const ::go::GameList& RoomInfo::games() const {
  const ::go::GameList* p = games_;
  // @@protoc_insertion_point(field_get:go.RoomInfo.Games)
  return p != nullptr ? *p : *reinterpret_cast<const ::go::GameList*>(
      &::go::_GameList_default_instance_);
}
inline ::go::GameList* RoomInfo::release_games() {
  // @@protoc_insertion_point(field_release:go.RoomInfo.Games)
  
  ::go::GameList* temp = games_;
  games_ = nullptr;
  return temp;
}
inline ::go::GameList* RoomInfo::mutable_games() {
  
  if (games_ == nullptr) {
    auto* p = CreateMaybeMessage<::go::GameList>(GetArenaNoVirtual());
    games_ = p;
  }
  // @@protoc_insertion_point(field_mutable:go.RoomInfo.Games)
  return games_;
}
inline void RoomInfo::set_allocated_games(::go::GameList* games) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete games_;
  }
  if (games) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      games = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, games, submessage_arena);
    }
    
  } else {
    
  }
  games_ = games;
  // @@protoc_insertion_point(field_set_allocated:go.RoomInfo.Games)
}

// -------------------------------------------------------------------

// GameBaseInfo

// uint32 Type = 1;
inline void GameBaseInfo::clear_type() {
  type_ = 0u;
}
inline ::google::protobuf::uint32 GameBaseInfo::type() const {
  // @@protoc_insertion_point(field_get:go.GameBaseInfo.Type)
  return type_;
}
inline void GameBaseInfo::set_type(::google::protobuf::uint32 value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:go.GameBaseInfo.Type)
}

// uint32 KindID = 2;
inline void GameBaseInfo::clear_kindid() {
  kindid_ = 0u;
}
inline ::google::protobuf::uint32 GameBaseInfo::kindid() const {
  // @@protoc_insertion_point(field_get:go.GameBaseInfo.KindID)
  return kindid_;
}
inline void GameBaseInfo::set_kindid(::google::protobuf::uint32 value) {
  
  kindid_ = value;
  // @@protoc_insertion_point(field_set:go.GameBaseInfo.KindID)
}

// uint32 Level = 3;
inline void GameBaseInfo::clear_level() {
  level_ = 0u;
}
inline ::google::protobuf::uint32 GameBaseInfo::level() const {
  // @@protoc_insertion_point(field_get:go.GameBaseInfo.Level)
  return level_;
}
inline void GameBaseInfo::set_level(::google::protobuf::uint32 value) {
  
  level_ = value;
  // @@protoc_insertion_point(field_set:go.GameBaseInfo.Level)
}

// string Name = 4;
inline void GameBaseInfo::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GameBaseInfo::name() const {
  // @@protoc_insertion_point(field_get:go.GameBaseInfo.Name)
  return name_.GetNoArena();
}
inline void GameBaseInfo::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:go.GameBaseInfo.Name)
}
#if LANG_CXX11
inline void GameBaseInfo::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:go.GameBaseInfo.Name)
}
#endif
inline void GameBaseInfo::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:go.GameBaseInfo.Name)
}
inline void GameBaseInfo::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:go.GameBaseInfo.Name)
}
inline ::std::string* GameBaseInfo::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:go.GameBaseInfo.Name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GameBaseInfo::release_name() {
  // @@protoc_insertion_point(field_release:go.GameBaseInfo.Name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GameBaseInfo::set_allocated_name(::std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:go.GameBaseInfo.Name)
}

// uint32 EnterScore = 5;
inline void GameBaseInfo::clear_enterscore() {
  enterscore_ = 0u;
}
inline ::google::protobuf::uint32 GameBaseInfo::enterscore() const {
  // @@protoc_insertion_point(field_get:go.GameBaseInfo.EnterScore)
  return enterscore_;
}
inline void GameBaseInfo::set_enterscore(::google::protobuf::uint32 value) {
  
  enterscore_ = value;
  // @@protoc_insertion_point(field_set:go.GameBaseInfo.EnterScore)
}

// uint32 LessScore = 6;
inline void GameBaseInfo::clear_lessscore() {
  lessscore_ = 0u;
}
inline ::google::protobuf::uint32 GameBaseInfo::lessscore() const {
  // @@protoc_insertion_point(field_get:go.GameBaseInfo.LessScore)
  return lessscore_;
}
inline void GameBaseInfo::set_lessscore(::google::protobuf::uint32 value) {
  
  lessscore_ = value;
  // @@protoc_insertion_point(field_set:go.GameBaseInfo.LessScore)
}

// -------------------------------------------------------------------

// GameItem

// uint32 ID = 1;
inline void GameItem::clear_id() {
  id_ = 0u;
}
inline ::google::protobuf::uint32 GameItem::id() const {
  // @@protoc_insertion_point(field_get:go.GameItem.ID)
  return id_;
}
inline void GameItem::set_id(::google::protobuf::uint32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:go.GameItem.ID)
}

// .go.GameBaseInfo Info = 2;
inline bool GameItem::has_info() const {
  return this != internal_default_instance() && info_ != nullptr;
}
inline void GameItem::clear_info() {
  if (GetArenaNoVirtual() == nullptr && info_ != nullptr) {
    delete info_;
  }
  info_ = nullptr;
}
inline const ::go::GameBaseInfo& GameItem::info() const {
  const ::go::GameBaseInfo* p = info_;
  // @@protoc_insertion_point(field_get:go.GameItem.Info)
  return p != nullptr ? *p : *reinterpret_cast<const ::go::GameBaseInfo*>(
      &::go::_GameBaseInfo_default_instance_);
}
inline ::go::GameBaseInfo* GameItem::release_info() {
  // @@protoc_insertion_point(field_release:go.GameItem.Info)
  
  ::go::GameBaseInfo* temp = info_;
  info_ = nullptr;
  return temp;
}
inline ::go::GameBaseInfo* GameItem::mutable_info() {
  
  if (info_ == nullptr) {
    auto* p = CreateMaybeMessage<::go::GameBaseInfo>(GetArenaNoVirtual());
    info_ = p;
  }
  // @@protoc_insertion_point(field_mutable:go.GameItem.Info)
  return info_;
}
inline void GameItem::set_allocated_info(::go::GameBaseInfo* info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete info_;
  }
  if (info) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    
  } else {
    
  }
  info_ = info;
  // @@protoc_insertion_point(field_set_allocated:go.GameItem.Info)
}

// -------------------------------------------------------------------

// MasterInfo

// .go.UserInfo UserInfo = 1;
inline bool MasterInfo::has_userinfo() const {
  return this != internal_default_instance() && userinfo_ != nullptr;
}
inline void MasterInfo::clear_userinfo() {
  if (GetArenaNoVirtual() == nullptr && userinfo_ != nullptr) {
    delete userinfo_;
  }
  userinfo_ = nullptr;
}
inline const ::go::UserInfo& MasterInfo::userinfo() const {
  const ::go::UserInfo* p = userinfo_;
  // @@protoc_insertion_point(field_get:go.MasterInfo.UserInfo)
  return p != nullptr ? *p : *reinterpret_cast<const ::go::UserInfo*>(
      &::go::_UserInfo_default_instance_);
}
inline ::go::UserInfo* MasterInfo::release_userinfo() {
  // @@protoc_insertion_point(field_release:go.MasterInfo.UserInfo)
  
  ::go::UserInfo* temp = userinfo_;
  userinfo_ = nullptr;
  return temp;
}
inline ::go::UserInfo* MasterInfo::mutable_userinfo() {
  
  if (userinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::go::UserInfo>(GetArenaNoVirtual());
    userinfo_ = p;
  }
  // @@protoc_insertion_point(field_mutable:go.MasterInfo.UserInfo)
  return userinfo_;
}
inline void MasterInfo::set_allocated_userinfo(::go::UserInfo* userinfo) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete userinfo_;
  }
  if (userinfo) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      userinfo = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, userinfo, submessage_arena);
    }
    
  } else {
    
  }
  userinfo_ = userinfo;
  // @@protoc_insertion_point(field_set_allocated:go.MasterInfo.UserInfo)
}

// repeated .go.RoomInfo RoomsInfo = 2;
inline int MasterInfo::roomsinfo_size() const {
  return roomsinfo_.size();
}
inline void MasterInfo::clear_roomsinfo() {
  roomsinfo_.Clear();
}
inline ::go::RoomInfo* MasterInfo::mutable_roomsinfo(int index) {
  // @@protoc_insertion_point(field_mutable:go.MasterInfo.RoomsInfo)
  return roomsinfo_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::go::RoomInfo >*
MasterInfo::mutable_roomsinfo() {
  // @@protoc_insertion_point(field_mutable_list:go.MasterInfo.RoomsInfo)
  return &roomsinfo_;
}
inline const ::go::RoomInfo& MasterInfo::roomsinfo(int index) const {
  // @@protoc_insertion_point(field_get:go.MasterInfo.RoomsInfo)
  return roomsinfo_.Get(index);
}
inline ::go::RoomInfo* MasterInfo::add_roomsinfo() {
  // @@protoc_insertion_point(field_add:go.MasterInfo.RoomsInfo)
  return roomsinfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::go::RoomInfo >&
MasterInfo::roomsinfo() const {
  // @@protoc_insertion_point(field_list:go.MasterInfo.RoomsInfo)
  return roomsinfo_;
}

// .go.TaskList Tasks = 3;
inline bool MasterInfo::has_tasks() const {
  return this != internal_default_instance() && tasks_ != nullptr;
}
inline void MasterInfo::clear_tasks() {
  if (GetArenaNoVirtual() == nullptr && tasks_ != nullptr) {
    delete tasks_;
  }
  tasks_ = nullptr;
}
inline const ::go::TaskList& MasterInfo::tasks() const {
  const ::go::TaskList* p = tasks_;
  // @@protoc_insertion_point(field_get:go.MasterInfo.Tasks)
  return p != nullptr ? *p : *reinterpret_cast<const ::go::TaskList*>(
      &::go::_TaskList_default_instance_);
}
inline ::go::TaskList* MasterInfo::release_tasks() {
  // @@protoc_insertion_point(field_release:go.MasterInfo.Tasks)
  
  ::go::TaskList* temp = tasks_;
  tasks_ = nullptr;
  return temp;
}
inline ::go::TaskList* MasterInfo::mutable_tasks() {
  
  if (tasks_ == nullptr) {
    auto* p = CreateMaybeMessage<::go::TaskList>(GetArenaNoVirtual());
    tasks_ = p;
  }
  // @@protoc_insertion_point(field_mutable:go.MasterInfo.Tasks)
  return tasks_;
}
inline void MasterInfo::set_allocated_tasks(::go::TaskList* tasks) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete tasks_;
  }
  if (tasks) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      tasks = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, tasks, submessage_arena);
    }
    
  } else {
    
  }
  tasks_ = tasks;
  // @@protoc_insertion_point(field_set_allocated:go.MasterInfo.Tasks)
}

// -------------------------------------------------------------------

// ReqEnterRoom

// uint32 RoomNum = 1;
inline void ReqEnterRoom::clear_roomnum() {
  roomnum_ = 0u;
}
inline ::google::protobuf::uint32 ReqEnterRoom::roomnum() const {
  // @@protoc_insertion_point(field_get:go.ReqEnterRoom.RoomNum)
  return roomnum_;
}
inline void ReqEnterRoom::set_roomnum(::google::protobuf::uint32 value) {
  
  roomnum_ = value;
  // @@protoc_insertion_point(field_set:go.ReqEnterRoom.RoomNum)
}

// string RoomKey = 2;
inline void ReqEnterRoom::clear_roomkey() {
  roomkey_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ReqEnterRoom::roomkey() const {
  // @@protoc_insertion_point(field_get:go.ReqEnterRoom.RoomKey)
  return roomkey_.GetNoArena();
}
inline void ReqEnterRoom::set_roomkey(const ::std::string& value) {
  
  roomkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:go.ReqEnterRoom.RoomKey)
}
#if LANG_CXX11
inline void ReqEnterRoom::set_roomkey(::std::string&& value) {
  
  roomkey_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:go.ReqEnterRoom.RoomKey)
}
#endif
inline void ReqEnterRoom::set_roomkey(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  roomkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:go.ReqEnterRoom.RoomKey)
}
inline void ReqEnterRoom::set_roomkey(const char* value, size_t size) {
  
  roomkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:go.ReqEnterRoom.RoomKey)
}
inline ::std::string* ReqEnterRoom::mutable_roomkey() {
  
  // @@protoc_insertion_point(field_mutable:go.ReqEnterRoom.RoomKey)
  return roomkey_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ReqEnterRoom::release_roomkey() {
  // @@protoc_insertion_point(field_release:go.ReqEnterRoom.RoomKey)
  
  return roomkey_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ReqEnterRoom::set_allocated_roomkey(::std::string* roomkey) {
  if (roomkey != nullptr) {
    
  } else {
    
  }
  roomkey_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), roomkey);
  // @@protoc_insertion_point(field_set_allocated:go.ReqEnterRoom.RoomKey)
}

// -------------------------------------------------------------------

// ReqEnterGame

// uint32 GameID = 1;
inline void ReqEnterGame::clear_gameid() {
  gameid_ = 0u;
}
inline ::google::protobuf::uint32 ReqEnterGame::gameid() const {
  // @@protoc_insertion_point(field_get:go.ReqEnterGame.GameID)
  return gameid_;
}
inline void ReqEnterGame::set_gameid(::google::protobuf::uint32 value) {
  
  gameid_ = value;
  // @@protoc_insertion_point(field_set:go.ReqEnterGame.GameID)
}

// -------------------------------------------------------------------

// ReqExitGame

// uint32 GameID = 1;
inline void ReqExitGame::clear_gameid() {
  gameid_ = 0u;
}
inline ::google::protobuf::uint32 ReqExitGame::gameid() const {
  // @@protoc_insertion_point(field_get:go.ReqExitGame.GameID)
  return gameid_;
}
inline void ReqExitGame::set_gameid(::google::protobuf::uint32 value) {
  
  gameid_ = value;
  // @@protoc_insertion_point(field_set:go.ReqExitGame.GameID)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace go

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // PROTOBUF_INCLUDED_login_2eproto
